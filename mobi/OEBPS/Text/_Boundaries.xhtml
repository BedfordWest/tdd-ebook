<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Specifying boundaries</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre4">
  <div class="disclaimer">
    <h3 class="sigilnotintoc2">A Disclaimer</h3>

    <p class="calibre2">Before I begin, I have to admit that this chapter is mostly based on the material from a series of posts by Scot Bain and Amir Kolsky from the blog Sustainable Test Driven Development and their upcoming book by the same title. I like their idea of boundaries so much that I just follow the guidelines they outlined. This chapter is going to be a rephrase of these guidelines. I placed it here so that you have all the important topics covered in one place, but I encourage you to read the original blog posts on this subject on http://www.sustainabletdd.com (and the upcoming book).</p>
  </div>

  <h1 id="sigil_toc_id_30" class="calibre1">Specifying Boundaries and Conditions</h1>

  <h2 id="sigil_toc_id_31" class="calibre5">Sometimes, Anonymous Value Is Not Enough</h2>

  <p class="calibre2">When we specify a behavior, there are times when this behavior should be the same no matter what arguments we pass to the constructor or invoked methods. An example would be an addition of two numbers - whatever numbers we would supply, the answer would always be a sum of those numbers:</p>
  <pre class="calibre10">[Fact] public void
ShouldCalculateTheSumOfTwoNumbers()
{
  //GIVEN
  var a = Any.Integer();
  var b = Any.Integer();

  //WHEN
  var result = new Sum().Of(a, b);

  //WHEN
  Assert.Equal(a + b, result);
}</pre>

  <p class="calibre2">In this case, the integer numbers can really be “any” - the described relationship between input and output is independent of the actual values we use. As indicated in one of the previous chapters, this is the canonical case where Constrained Non-Determinism applies.</p>

  <p class="calibre2">Sometimes, however, objects exhibit different behaviors based on what is passed to their constructor and to their methods (OK, we also have static methods and singletons. Longer discussion on those will be included in one of the next chapters - for now we can safely ignore them). For example, in our application we may have a licensing policy where a feature is allowed to use only if the license is valid, and denied after it has expired. Another example would be that some shops are open from 10:00 to 18:00, so if we had a query in our application whether the shop is currently open, we would expect it to be answered differently based on what the current time is.</p>

  <p class="calibre2">In such cases, Scott and Amir offer us other guidelines for choosing input values.</p>

  <h2 id="sigil_toc_id_32" class="calibre5">Exceptions To The Rule</h2>

  <p class="calibre2">There are times, when a Statement is true for every value except one (or more) explicitly specified. For example, in Poland, high school students are graded for exams between “mediocre” and “very good”. Every grade means the exam is passed except for “mediocre” grade which means the exam is failed. If we imagine we have to specify an object that decides whether the exam is passed based on rating, we would have to write two Statements: one for the mediocre rating and other for all the others.</p>

  <p class="calibre2">Here is the Statement for mediocre grade (let us imagine that all grades are members of an enum):</p>
  <pre class="calibre10">[Fact] public void
ShouldNotPassTheExamWhenGradeIsMediocre()
{
  //GIVEN
  var decision = new PassOrNotDecision();

  //WHEN
  var examPassed = decision.MakeBasedOn(Grades.Mediocre);

  //THEN
  Assert.False(examPassed);
}</pre>

  <p class="calibre2">Note that here, we used the literal value of <code class="calibre11">Grades.Mediocre</code>. This is because no other value gives the same behavior as this one, so generating the value would not make any sense.</p>

  <p class="calibre2">The second Statement is for all the other cases. Here, we are going to use another method of the <code class="calibre11">Any</code> class for generating ay enum member other than specified:</p>
  <pre class="calibre10">[Fact] public void
ShouldPassTheExamWhenGradeIsOtherThanMediocre()
{
  //GIVEN
  var decision = new PassOrNotDecision();

  //WHEN
  var examPassed 
    = decision.MakeBasedOn(Any.Besides(Grades.Mediocre));<br class="calibre6"/>
  //THEN
  Assert.True(examPassed);
}</pre>

  <p class="calibre2">Here, <code class="calibre11">Any.Besides()</code> takes care of the enum value generation, producing a nice, readable code as a side effect.</p>

  <p class="calibre2">The example shown above assumes there is only one exception to the rule (the mediocre grade). However, this concept can be scaled up to more values, as long as it is a finished, discrete set. If there are multiple exceptional values that produce the same behavior, a single Statement is sufficient to cover them all (using <code class="calibre11">Any</code> class and making the following call for exception Statement: <code class="calibre11">Any.Of(value1, value2)</code> and the following for the rest: <code class="calibre11">Any.OtherThan(value1, value2)</code>). However, when there are multiple exceptions to the rule and each one triggers a different behavior, each one deserves its own Statement.</p>

  <h2 id="sigil_toc_id_33" class="calibre5">Rules Valid Within Boundaries</h2>

  <p class="calibre2">Sometimes, a behavior varies around a numerical boundary. the simplest example would be a set of rules on how to calculate an absolute value of a number:</p>

  <ol class="calibre12">
    <li class="calibre13">for any X less than 0, the result is -X (e.g. absolute value of -1.5 is 1.5)</li>

    <li class="calibre13">for any X greater or equal to 0, the result is X (e.g. absolute value of 3 is 3).</li>
  </ol>

  <p class="calibre2">As you can see, there is a boundary between the two behaviors and the right edge of the boundary is 0. Why do I say “right edge”? That is because the boundary always has two edges and there’s a length between them. If we assume we are talking about the mentioned absolute value calculation and that our numerical domain is that of integer numbers, we can as well use -1 as edge value and say that:</p>

  <ol class="calibre12">
    <li class="calibre13">for any X less or equal to -1, the result is -X (e.g. absolute value of -1.5 is 1.5)</li>

    <li class="calibre13">for any X greater than -1, the result is X (e.g. absolute value of 3 is 3).</li>
  </ol>

  <p class="calibre2">So a boundary is not a single number - it always has a length - the length between last value of the previous behavior and the first value of the next behavior. In case of our example, the length between -1 (left edge - last negated number) and 0 (right edge - first non-negated) is 1.</p>

  <p class="calibre2">Now, imagine that we are not talking about integer values anymore, but about floating point values. Then the right edge value would still be 0. But what about left edge? It would not be possible for it to stay -1, because the rule applies to e.g. -0.9 as well. So what is the correct right edge value and the correct length of the boundary? Would the length be 0.1? Or 0.001? Or maybe 0.00000001? This is harder to answer and depends heavily on the context, but it is something that must be answered for each particular case - this way we know what kind of precision is expected of us. In our Specification, we have to document the boundary length somehow.</p>

  <p class="calibre2">So the next topic is: how to describe the boundary length with Statements? To illustrate this, I want to show you two Statements assuming we’re implementing the mentioned absolute value calculation for integers. The first Statement is for values smaller than 0 and we want to use the left edge value here ilke this:</p>
  <pre class="calibre10">[Fact] public void
ShouldNegateTheNumberWhenItIsLessThan0()
{
  //GIVEN
  var function = new AbsoluteValueCalculation();
  var lessThan0 = 0 - 1;

  //WHEN
  var result = function.PerformFor(lessThan0);

  //THEN
  Assert.Equal(-lessThan0, result);
}</pre>

  <p class="calibre2">And the next Statement for values at least 0 and we want to use the right edge value:</p>
  <pre class="calibre10">[Fact] public void
ShouldNotNegateTheNumberWhenItIsGreaterOrEqualTo0()
{
  //GIVEN
  var function = new AbsoluteValueCalculation();
  var moreOrEqualTo0 = 0;

  //WHEN
  var result = function.PerformFor(moreOrEqualTo0);

  //THEN
  Assert.Equal(moreOrEqualTo0, result);
}</pre>

  <p class="calibre2">There are two things to note about these examples. The first one is that we don’t use any kind of <code class="calibre11">Any</code> methods. We explicitly take the edges, because they’re the numbers that most strictly define the boundary. This way we document the boundary length.</p>

  <p class="calibre2">It is important to understand why we are not using methods like <code class="calibre11">Any.IntegerGreaterOrEqualTo(0)</code>, even though we do use <code class="calibre11">Any</code> in case when we have no boundary. This is because in the latter case, no value is better than the other in any particular way. In case of boundaries, however, the edge values are better in that they more strictly define the boundary and drive the right implementation.</p>

  <p class="calibre2">The second thing to note is the usage of literal constant 0 in the above example. In one of the previous chapter, I showed you a technique called <strong class="calibre14">Constant Specification</strong>, where we write an explicit Statement about the value of the named constant and use the named constant everywhere else instead of its literal. So why did i not use this technique?</p>

  <p class="calibre2">The only reason is that this might have looked a little bit silly with such extremely trivial example as calculating absolute value. In reality, I should have used the named constant in both Statements and it would show the boundary length even more clearly. Actually, let use perform this exercise now and see what happens.</p>

  <p class="calibre2">First, let us document the named constant:</p>
  <pre class="calibre10">[Fact] public void
ShouldIncludeSmallestValueNotToNegateSetToZero()
{
  Assert.Equal(0, Constants.SmallestValueNotToNegate);
}</pre>

  <p class="calibre2">Now we have got everything we need to rewrite the two Statements we wrote earlier. The first would look like this:</p>
  <pre class="calibre10">[Fact] public void
ShouldNegateTheNumberWhenItIsLessThanSmallestValueNotToNegate()
{
  //GIVEN
  var function = new AbsoluteValueCalculation();
  var lastNumberToNegate 
    = Constants.SmallestValueNotToNegate - 1;

  //WHEN
  var result = function.PerformFor(lastNumberToNegate);

  //THEN
  Assert.Equal(-lastNumberToNegate, result);
}</pre>

  <p class="calibre2">And the second Statement for values at least 0:</p>
  <pre class="calibre10">[Fact] public void
ShouldNotNegateNumberWhenItIsGreaterOrEqualToSmallestValueNotToNegate()
{
  //GIVEN
  var function = new AbsoluteValueCalculation();

  //WHEN
  var result = function.PerformFor(
    Constants.SmallestValueNotToNegate
  );

  //THEN
  Assert.Equal(
    Constants.SmallestValueNotToNegate, result);
}</pre>

  <p class="calibre2">As you can see, the first Statement contains the following expression: <code class="calibre11">Constants.SmallestValueNotToNegate - 1</code>, where 1 is the exact length of the boundary. Like I said, the situation is so trivial that it may look silly and funny, however, in real life scenarios, this is a great technique to apply anytime, anywhere.</p>

  <p class="calibre2">Boundaries may look like they apply only to integer input, but they occur at many other places. There are boundaries associated with date/time (e.g. an action is performed again when time from last action is at least 30 seconds - the decision would need to be made whether we need precision in seconds or maybe in ticks), to strings (e.g. validation of user name where it must be at least 2 characters, or password that must contain at least 2 special characters) etc.</p>

  <h2 id="sigil_toc_id_34" class="calibre5">Combination of Boundaries - Ranges</h2>

  <p class="calibre2">So, what about a behavior that is valid in a range? Let us assume that we live in a country where a citizen can get a driving license only after their 17th birthday, but before 65th (the government decided that people after 65 have worse sight and it’s safer not to give them new driving licenses). Let us also assume that we try to develop a class that answers the question whether we can apply for driving license and the return values of this query are as follows:</p>

  <ol class="calibre12">
    <li class="calibre13">Age &lt; 17 - returns enum value <code class="calibre11">QueryResults.TooYoung</code></li>

    <li class="calibre13">17 &lt;= age &gt;= 65 - returns enum value <code class="calibre11">QueryResults.AllowedToApply</code></li>

    <li class="calibre13">Age &gt; 65 - returns enum value <code class="calibre11">QueryResults.TooOld</code></li>
  </ol>

  <p class="calibre2">Now, remember I told you that we specify the behaviors near boundaries? This, however, when applied to the situation I just described, would give us the following Statements:</p>

  <ol class="calibre12">
    <li class="calibre13">Age = 17, should yield result <code class="calibre11">QueryResults.TooYoung</code></li>

    <li class="calibre13">Age = 18, should yield result <code class="calibre11">QueryResults.AllowedToApply</code></li>

    <li class="calibre13">Age = 65, should yield result <code class="calibre11">QueryResults.AllowedToApply</code></li>

    <li class="calibre13">Age = 66, should yield result <code class="calibre11">QueryResults.TooOld</code></li>
  </ol>

  <p class="calibre2">thus, we would describe the behavior where the query should return <code class="calibre11">AllowedToApply</code> value twice, which effectively means that we would copy-paste the Statement and change just one value. How do we deal with this? Thankfully, we have a solution available:</p>

  <p class="calibre2">Most xUnit frameworks provide some kind of data-driven test functionality, which we can use to write parameterized Statements. The functionality basically means that we can write the code of the Statement once, but make the xUnit framework invoke it twice with different sets of input values. Let’s see an example in XUnit.net:</p>
  <pre class="calibre10">[Theory]
[InlineData(17, QueryResults.TooYoung)]
[InlineData(18, QueryResults.AllowedToApply)]
[InlineData(65, QueryResults.AllowedToApply)]
[InlineData(66, QueryResults.TooOld)]
public void ShouldYieldResultForAge(int age, QueryResults expectedResult)
{
  //GIVEN
  var query = new DrivingLicenseQuery();

  //WHEN
  var result = query.ExecuteFor(age);

  //THEN
  Assert.Equal(expectedResult, result);
}</pre>

  <p class="calibre2">This way, there is only one Statement executed four times. The case of <code class="calibre11">AllowedToApply</code> is still evaluated twice for both edge cases (so there is more time spent on executing it, which for small cases is not an issue), but the code maintenance issue is gone - we don’t have to copy-paste the code to specify both edges of the behavior.</p>

  <p class="calibre2">Note that we’re quite lucky because the specified logic is strictly functional (i.e. returns different results based on different inputs). Thanks to this, we could parameterize input values together with expected results. This is not always the case. For example, let us imagine that we have a clock class where we can set alarm time. The class allows us to set hour between 0 and 24, but otherwise throws an exception.</p>

  <p class="calibre2">While some xUnit frameworks, like NUnit, allow us to handle both cases with one Statement by writing something like this:</p>
  <pre class="calibre10">//NOTE: this is an example in NUnit framework!
[TestCase(Hours.Min, Result=Hours.Min)]
[TestCase(Hours.Max, Result=Hours.Max)]
[TestCase(Hours.Min-1, ExpectedException = typeof(OutOfRangeException))]
[TestCase(Hours.Max+1, ExpectedException = typeof(OutOfRangeException))]
public int 
ShouldBeAbleToSetHourBetweenMinAndMaxButNotOutsideThatRange(
  int inputHour)
{
  //GIVEN
  var clock = new Clock();
  clock.SetAlarmHour(inputHour);

  //WHEN
  var setHour = clock.GetAlarmHour();

  //THEN
  return setHour;
}</pre>

  <p class="calibre2">Others, like XUnit.NET, don’t (not that it’s a defect of the framework, it’s just that the philosophy behind those two is a little bit different and that some features have hidden price attached to their usage which some frameworks are willing to pay, while others aren’t). Thus, we have to solve it by writing two parameterized Statements - one where a value is returned (for valid cases) and one where exception is thrown (for invalid cases). The first would look like this:</p>
  <pre class="calibre10">[Theory]
[InlineData(Hours.Min)]
[InlineData(Hours.Max)]
public void 
ShouldBeAbleToSetHourBetweenMinAndMax(int inputHour)
{
  //GIVEN
  var clock = new Clock();
  clock.SetAlarmHour(inputHour);

  //WHEN
  var setHour = clock.GetAlarmHour();

  //THEN
  Assert.Equal(inputHour, setHour);
}</pre>

  <p class="calibre2">and the second:</p>
  <pre class="calibre10">[Theory]
[InlineData(Hours.Min-1)]
[InlineData(Hours.Max+1)]
public void 
ShouldThrowOutOfRangeExceptionWhenTryingToSetAlarmHourOutsideValidRange(
  int inputHour)
{
  //GIVEN
  var clock = new Clock();

  //WHEN - THEN
  Assert.Throws&lt;OutOfRangeException&gt;( 
    ()=&gt; clock.SetAlarmHour(inputHour)
  );
}</pre>

  <h2 id="sigil_toc_id_35" class="calibre5">Summary</h2>

  <p class="calibre2">In this chapter, we covered specifying numerical boundaries with a minimal amount of code, so that the Specification is more maintainable and runs fast. There is one more kind of situation left: when we have compound conditions (e.g. a password must be at least 10 characters and contain at least 2 special characters) - we’ll get back to those when we introduce mocks.</p>
</body>
</html>

<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>How to start?</title>
  <link href="../Styles/Global.css" rel="stylesheet" type="text/css" />
</head>

<body>
  <h1>How to start?</h1>

  <p>Whenever I sat down with a person that was about to write their first code in a Statement-first manner, the person would first stare at the screen, then at me, then would say: "what now?". It's easy to say: "You know how to write code, you know how to write a unit test for it, just this time start with the latter rather than the first", but for many people, this is something that blocks them completely. If you're one of them, don't worry - you're not alone. I decided to dedicate this chapter solely to techniques for starting to write a Statement when there's no code.</p>

  <h2 id="sigil_toc_id_25">Start with a good name</h2>

  <p>It may sound obvious, but really some people are having trouble describing the behavior they expect from their code. If you can name such behavior, it's a great starting point.</p>

  <p>I know some people don't pay attention to naming their Statements, mainly because they're considered as tests and second-level citizens - as long as they run and "prove the code does not contain defects", they're considered sufficient. We'll take a look at some examples of bad names and then I'd like to introduce to you some rules of good naming.</p>

  <h3 id="sigil_toc_id_27">Consequences of bad naming</h3>

  <p>As I said, many people don't really care how their Statements are named. This is a symptom of treating the Specification as garbage or leftovers - such situation is dangerous, because as soon as this kind of thinking is established, it leads to bad, unmaintainable Specification that looks more like lumps of accidental code put together in a haste than a living documentation. Imagine that your Specification consists of names like this:</p>

  <ul>
    <li><code>TrySendPacket()</code></li>

    <li><code>TrySendPacket2()</code></li>

    <li><code>testSendingManyPackets()</code></li>

    <li><code>testWrongPacketOrder1()</code></li>

    <li><code>testWrongPacketOrder2()</code></li>
  </ul>

  <p>and try for yourself how difficult it is to answer the following questions:</p>

  <ol>
    <li>How do you know what situation each Statement describes?</li>

    <li>How do you know whether the Statement describes a single situation, or few of them at the same time?</li>

    <li>How do you know whether the assertions inside those Statements are really the right ones assuming each Statement was written by someone else or was written a long time ago?</li>

    <li>How do you know whether the Statement should stay or be removed when you modify the functionality specified by the it?</li>

    <li>If your changes in production code make a Statement evaluate to false, how do you know whether the Statement is no longer correct or the production code is wrong?</li>

    <li>How do you know whether you will not introduce a duplicate Statement for a behavior that's already specified by another Statement when adding to Specification originally created by another team member?</li>

    <li>How do you estimate, by looking at the runner tool report, whether the fix for failing Statement will be easy or not?</li>

    <li>How do you answer a new developer in your team when they ask you "what is this Statement for?"</li>

    <li>How can you keep track of the Statements already made about the specified class vs those that still need to be made?</li>
  </ol>

  <h3 id="sigil_toc_id_26">What's in a good name?</h3>

  <p>For the name of the Statement to be of any use, it has to describe the expected behavior. At minimum, it should describe what happens at what circumstances. Let's take a look at one of the names Steve freeman and Nat Pryce came up in their great book Growing Object Oriented Software Guided By Tests:</p>
  <pre>notifiesListenersThatServerIsUnavailableWhenCannotConnectToItsMonitoringPort()</pre>

  <p>Note few things about the name of the Statement:</p>

  <ol>
    <li>It describes a behavior of an instance of a specified class. Note that it does not contain method name, because what is specified is not a method, but a behavior that has its entry point and expected result. The name simply tells that what an instance does (notifies listeners that server is unavailable) under certain circumstances (when cannot connect to its monitoring port). It's important because such description is what you can derive from thinking about responsibilities of a class, so you don't need to know any of its methods signatures or the code that's inside of the class. Hence, this is something you can come up without before implementing - you just need to know why you created this class and feed on it.</li>

    <li>
      <p>The name is long. Really, really, <strong>really</strong> don't worry about it. As long as you're describing a single behavior, it's alright. I know usually people are hesitant to give long names to the Statements, because they try to apply the same rules to those names as method names in production code. Let me make it clear - these two cases are different. In case of Statements, they're not invoked by anyone besides the automatic runner applications, so they won't obfuscate any code that would need to call them. Sure, we could put all the information in the comment instead of Statement name and leave the name short, like this:</p>
      <pre>[Fact]
//Notifies listeners that server 
//is unavailable when cannot connect
//to its monitoring port
public void Statement_002()
{
 //...
}
</pre>

      <p>There are two downsides of this solution: one is that we now have to put extra information (<code>Statement_002</code>) which is required only by compiler, because every method needs to have a name - there's usually no value a human could derive from such a name. The second downside is that when the Statement is evaluated to false, the automated runner shows you the following line: <code>Statement_002: FAILED</code> - note that all the information included in the comment isn't present in the failure report. It's really better to receive a report such as: <code>notifiesListenersThatServerIsUnavailableWhenCannotConnectToItsMonitoringPort: FAILED</code>, because all the information about the Statement that fails is present in the runner window.</p>
    </li>

    <li>Using a name that describes a (single) behavior allows you to track quickly why the Statement is false when it is. Suppose a Statement is true when you start refactoring, but in the meantime it turns out to be false and the report in the runner looks like this: <code>TrySendingHttpRequest: FAILED</code> - it doesn't really tell you anything more than an attempt is made to send a HTTP request, but, for instance, does not tell you whether your specified object is the sender (that should try to send this request under some circumstances) or the receiver (that should handle such request properly). To actually know what went wrong, you have to go to the code to scan its source code. Now compare it to the following name: <code>ShouldRespondWithAnAckWheneverItReceivedAHttpRequest</code>. Now when it evaluates to false, you can tell that what is broken is that the object no longer responds with an ACK to HTTP request. Sometimes this is enough to deduct which part of the code is in fault of this evaluation failure.</li>
  </ol>

  <h3 id="sigil_toc_id_28">My favourite convention</h3>

  <p>There are many conventions for naming Statements appropriately. My favorite is the one developed by Dan North, which makes each Statement name begin with the word <code>Should</code>. So for example, I'd name a Statement: <code>ShouldReportAllErrorsSortedAlphabeticallyWhenItEncountersErrorsDuringSearch()</code>. The name of the Specification (i.e. class name) answers the question "who should do it?", i.e. when I have a class names <code>SortingOperation</code> and want to say that it "should sort all items in ascending order when performed", I say it like this:</p>
  <pre>public class SortingOperationSpecification
{
 [Fact] public void
 ShouldSortAllItemsInAscendingOrderWhenPerformed()
 {
 }
}
</pre>

  <p>It's important to focus on what result is expected from an object when writing names along this convention. If you don't, you quickly find it troublesome. As an example, one of my colleague was specifying a class <code>UserId</code> and wrote the following name for the Statement about comparison of two identifiers: <code>EqualOperationShouldPassForTwoInstancesWithTheSameUserName()</code>. Note that this is not from the perspective of a single object, but rather from the perspective of an operation that's executed on it, which means that we stopped thinking in terms of object responsibilities and started thinking in terms of operation correctness, which is farther away from our assumption that we're writing a Specification consisting o Statements. This name should be changed to: <code>ShouldReportThatItIsEqualToAnotherObjectWhenItHasTheSameUserName()</code>.</p>

  <h2>A structure of a Statement</h2>

  <p>It often helps to think about each Statement of behavior in terms of its assumptions, a trigger for the behavior, and the expected result. <b>TODO: write about gherkin</b></p>

  <h2 id="sigil_toc_id_31">Start by filling the GIVEN-WHEN-THEN structure with the obvious</h2>

  <p>This is applicable when you come up with a GIVEN-WHEN-THEN structure for the Statement or a good name for it (GIVEN-WHEN-THEN structure can be easily derived from a good name and vice versa). Anyway, this method is about taking the GIVEN-WHEN-THEN parts and translating them into code in almost brute-force way, then add all the missing pieces that are required for the code to compile and run.</p>

  <h3>An example speaks for thousand words</h3>

  <p>Let's take a simple example of sorting numbers of comparing two users. We assume that a user should be equal to another when it has the same name as the other one:</p>
  <pre style="padding: 1em; border: dashed thin gray;">GIVEN a user with any name
WHEN I compare it to another user with the same name
THEN it should appear equal to this other user
</pre>

  <p>Let's start with the translation</p>

  <p>The first line:</p>
  <pre style="padding: 1em; border: dashed thin gray;">GIVEN a user with any name</pre>

  <p>can be translated literally to code like this:</p>
  <pre class="brush: csharp">var user = new User(anyName);</pre>

  <p>Then the second line:</p>
  <pre style="padding: 1em; border: dashed thin gray;">WHEN I compare it to another user with the same name</pre>

  <p>can be written as:</p>
  <pre class="brush: csharp">user.Equals(anotherUserWithTheSameName);</pre>

  <p>Great! Now the last line:</p>
  <pre style="padding: 1em; border: dashed thin gray;">THEN it should appear equal to this other user</pre>

  <p>and its translation into the code:</p>
  <pre class="brush: csharp">Assert.True(areUsersEqual);</pre>

  <p>Ok, so we've made the translation, now let's summarize this and see what's missing to make this code compile:</p>
  <pre class="brush: csharp">[Fact] public void 
ShouldAppearEqualToAnotherUserWithTheSameName()
{
  //GIVEN
  var user = new User(anyName);

  //WHEN
  user.Equals(anotherUserWithTheSameName);

  //THEN
  Assert.True(areUsersEqual);
}
</pre>

  <p>As we expected, this will not compile. Notably, the following is missing:</p>

  <ol>
    <li>A declaration of <code>anyName</code> variable</li>

    <li>A declaration of <code>anyUserWithTheSameName</code> object</li>

    <li>The variable <code>areUsersEqual</code> is both not declared and it does not hold the comparison result</li>
  </ol>

  <p>So note that while we don't have full compiling code filling the gaps boils down to making a few declarations and assignments:</p>

  <ol>
    <li><code>anyName</code> can be declared as <code>var anyName = Any.String();</code></li>

    <li><code>anotherUserWithTheSameName</code> can be declared as <code>var anotherUserWithTheSameName = new User(anyName);</code></li>

    <li><code>areUsersEqual</code> can be declared and assigned this way: <code>var areUsersEqual = user.Equals(anotherUserWithTheSameName);</code></li>
  </ol>

  <p>Putting it all together:</p>
  <pre class="brush: csharp">[Fact] public void 
ShouldAppearEqualToAnotherUserWithTheSameName()
{
  //GIVEN
  var anyName = Any.String();
  var user = new User(anyName);
  var anotherUserWithTheSameName = new User(anyName);

  //WHEN
  var areUsersEqual = user.Equals(anotherUserWithTheSameName);

  //THEN
  Assert.True(areUsersEqual);
}
</pre>

  <p>And that's it - the Statement is complete!</p>

  <h2 id="sigil_toc_id_30">Start at the end</h2>

  <p>TODO</p>

  <h2 id="sigil_toc_id_32">Start by invoking a method when you have one</h2>
</body>
</html>

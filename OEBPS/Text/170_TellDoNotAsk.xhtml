<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Test-Driven Development - Extensive Tutorial</title>
        <link href="../Styles/Global.css" rel="stylesheet" type="text/css"/>
    </head>
    <body>
<h1>Telling, not asking</h1>

<p>In this chapter, we'll get back to Johnny and Benjamin as they introduce another change in the code they were given. In the process, they discover the impact that return values and getters have on composability of objects.</p>

<h1>Contractors</h1>

  <p><strong>Johnny:</strong> G'morning. Ready for another task?</p>

  <p><strong>Benjamin:</strong> Of course! What's next?</p>

  <p><strong>Johnny:</strong> Remember the code we worked yesterday? It container policy for permanent employees of the company. But the company wants to start hiring contractors and needs to include them in the application.</p>

  <p><strong>Benjamin:</strong> So we need to implement company policies for them?</p>

  <p><strong>Johnny:</strong> That's right. And the policies are going to be different for contractors. I mean, just as regular employees, they receive raises and bonuses, just the formulas are different. I made a small table to allow comparing what we have for regular employees and what we want to add for contractors:</p>

<table>
 <tr>
  <th></th>
  <th>Raise</th>
  <th>Bonus</th>
 </tr>

 <tr>
  <th>Regular Employee</th>
  <td>+10% of current salary if not reached maximum on a given pay grade</td>
  <td>+200% of current salary one time after five years</td>
 </tr>

 <tr>
  <th>Contractor</th>
  <td>+5% of average salary calculated for last 3 years of service (or all previous years of service if they have worked for less than 3 years)</td>
  <td>+10% of current salary when a contractor receives score more than 100 for the previous year</td>
 </tr>
</table>

<p>So the workflow is going to be the same for both a regular employee and a contractor:</p>

<ol>
  <li>Load from repository</li>
  <li>Evaluate raise</li>
  <li>Evaluate bonus</li>
  <li>Save</li>
</ol>

<p>but the implementation of some of the steps will be different for both.</p>

 <p><strong>Benjamin:</strong> Correct me if I am wrong, but these "load" and "save" steps do not look like they belong with the remaining two - they describe something technical, while the other steps describe something strictly related to how the company operates...</p>

  <p><strong>Johnny:</strong> Good catch, however, this is something we'll deal with later. Remember the scout rule - just leave it in no worse shape than it was before. Still, we're going to fix some design flaws anyway.</p>

 <p><strong>Benjamin:</strong> Aww... I'd just fix all of it now.</p>

  <p><strong>Johnny:</strong> Ha ha, patience, Luke. For now, let's look at the code we have now before we plan further steps.</p>

 <p><strong>Benjamin:</strong> Let me just open my IDE... OK, here it is:</p>

<pre>public class CompanyPolicies 
{
  readonly Repository _repository; 

  public CompanyPolicies(Repository repository)
  {
    _repository = repository;
  }
  
  public void ApplyYearlyIncentivePlan()
  {
    var employees = _repository.CurrentEmployees();

    foreach(var employee in employees)
    {
      var payGrade = employee.GetPayGrade();

      //evaluate raise
      if(employee.GetSalary() &lt; payGrade.Maximum)
      {
        var newSalary 
          = employee.GetSalary() 
          + employee.GetSalary() 
          * 0.1;
        employee.SetSalary(newSalary);
      }
      
      //evaluate one-time bonus
      if(employee.GetYearsOfService() == 5)
      {
        var oneTimeBonus = employee.GetSalary() * 2;
        employee.SetBonusForYear(2014, oneTimeBonus);
      }
      
      employee.Save();
    }
  }
}</pre>

 <p><strong>Benjamin:</strong> Look, Johnny, the class in fact contains all the four steps you mentioned, but their literal implementation for regular employees is just inserted there.</p>

  <p><strong>Johnny:</strong> Time to consider our options again. Well?</p>

 <p><strong>Benjamin:</strong> I can see two options. The first one would be to create another class like <code>CompanyPolicies</code>, called something like <code>CompanyPoliciesForContractors</code> and implement the new logic there. This would let us leave the original class as is, but we would have to change the places that use <code>CompanyPoliciesForContractors</code> to use both classes. Also, we would have to add a separate method to repository for retrieving the contractors.</p>

  <p><strong>Johnny:</strong> Also, we would miss our chance to communicate through the code that the sequence of steps is intentionally similar in both cases. Others who read this code in the future will see that the implementation for regular employees follows the steps: load, evaluate raise, evaluate bonus, save. When they look at the implementation for contractors, they will see the same order of steps, but they will be unable to tell whether the similarity is intentional, or is it there by pure accident.</p>

 <p><strong>Benjamin:</strong> So our second option is to put an <code>if</code> statement in every step inside the <code>CompanyPolicies</code> class, to distinguish between regular employees and contractors. The Employee class would have an <code>isContractor()</code> method and depending on what it would return, we would either execute the logic for regular employees or for contractors. Assuming that the current structure of the code looks like this:</p>

<pre>
foreach(var employee in employees)
{
  //evaluate raise
  ...
      
  //evaluate one-time bonus
  ...
  
  //save employee
}
</pre>

<p>the new structure would look like this:</p>

<pre>foreach(var employee in employees)
{
  if(employee.IsContractor())
  {
    //evaluate raise for contractor
    ...
  }
  else
  {
    //evaluate raise for regular
    ...
  }

  if(employee.IsContractor())
  {
    //evaluate one-time bonus for contractor
    ...
  }
  else
  {
    //evaluate one-time bonus for regular
    ...
  }
  
  //save employee
  ...
}
</pre>

<p>this way we would show that the steps are the same, but the implementation is different. Also, this would mostly require us to add code and not move the existing code around.</p>

  <p><strong>Johnny:</strong> The downside is that we would make the class even uglier than it was when we started. So despite initial easiness, we'll be doing a huge disservice for future maintainers. We have at least one another option. What would that be?</p>

 <p><strong>Benjamin:</strong> Let's see... we could move all the details concerning the implementation of the steps from <code>CompanyPolicies</code> class into the <code>Employee</code> class itself, leaving only the names and the order of steps in <code>CompanyPolicies</code>:

<pre>foreach(var employee in employees)
{
  employee.EvaluateRaise();
  employee.EvaluateOneTimeBonus();
  employee.Save();
}
</pre>


<p>Then, we could change the <code>Employee</code> into an interface, so that it could be either a <code>RegularEmployee</code> or <code>ContractorEmployee</code> - both classes would have different implementations of the steps, but the <code>CompanyPolicies</code> would not notice, since it would not be coupled to the implementation of the steps anymore - just the names and the order.</p>

  <p><strong>Johnny:</strong> This solution would have one downside - we would need to significantly change the current code, but you know what? I'm willing to do it, especially that I was told today that the logic is covered by some tests which we can run to see if a regression was introduced.</p>

 <p><strong>Benjamin:</strong> Cool, what do we start with?</p>

  <p><strong>Johnny:</strong> The first thing that is between us and our goal are these getters on the <code>Employee</code> Employee class:</p>

<pre>GetSalary();
GetGrade();
GetYearsOfService();
</pre>

<p>They just expose too much information specific to the regular employees. This is also the case with these setters:</p>
<pre>
SetSalary(newSalary)
SetBonusForYear(year, amount);
</pre>



    </body>
</html>
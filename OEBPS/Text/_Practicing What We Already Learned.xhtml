<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Practicing what we already learned</title>
</head>

<body>
  <blockquote>
    <p>And now, a taste of things to come!</p>

    <p>- Shang Tsung, Mortal Kombat The Movie</p>
  </blockquote>

  <p>The above quote took place just before a fighting scene in which a nameless warrior jumped at Sub-Zero only to be frozen and broken into multiple pieces upon hitting the wall. The scene was not spectacular in terms of fighting technique or length. Also, the nameless guy didn't even try hard - the only thing he did was to jump only to be hit by a freezing ball, which, by the way, he actually saw coming. It looked a lot like the fight was set up only to showcase Sub-Zero's freezing ability. Guess what? In this chapter, we're gonna do roughly the same thing - set up a fake, easy scenario just to showcase some of the basic TDD elements!</p>

  <p>The previous chapter was filled with a lot of theory and philosophy, don't you think? I really hope you didn't fall asleep while reading it. To tell you the truth, we need to grasp much more theory until we are really able to write real-world applications using TDD. To compensate for this somehow, I propose we make a side trip from the trail and try what we already learned on a quick and easy example. As we go through the example, you might wonder how on earth could you possibly write real applications the way we'll write our simple program. Don't worry, I won't show you all the tricks yet, so treat it as a "taste of things to come". In other words, the example will be as close to real world problems as the fight between Sub-Zero and nameless ninja was to real martial arts fight, but will show you some of the elements of TDD process.</p>

  <h2>Let me tell you a story<br /></h2>

  <p>Meet Johnny and Benjamin, two developers from Buthig Company. Johnny is quite fluent in programming and Test-Driven Development, while Benjamin is an intern under Johnny's mentorship and is eager to learn TDD. They're on their way to their customer, Jane, who requested their presence as she wants them to do write a small program for her. Together with them, we'll see how they interact with the customer and how Benjamin tries to understand the basics of TDD. Just as you, Benjamin is a novice so his questions may reflect yours. However, if you find anything explained in not enough details, don't worry - in the next chapters, we'll be expanding on this material.&nbsp;</p>

  <h2>Act 1: The Car</h2>

  <p>Johnny: How do you feel on your first assignment?</p>

  <p>Benjamin: I'm pretty excited! I hope I can learn some of the TDD stuff you promised to teach me.</p>

  <p>Johnny: Not only TDD, but we're also gonna use some of the practices associated with a process called Acceptance Test Driven Development, albeit in a simplified form.</p>

  <p>Benjamin: Acceptance Test-Driven Development? What is that?</p>

  <p>Johnny: While TDD is usually referred to as a development technique, ATDD is something more of a collaboration method. Both ATDD and TDD have a bit of analysis in them and work very well together as both use the same underlying principles, just on different levels. We'll need only a small subset of what ATDD has to offer, so don't get over-excited.</p>

  <p>Benjamin: Sure.</p>

  <h2>Act 2: The Customer</h2>

  <p>Johnny: Hi, Jane, how are you?</p>

  <p>Jane: Thanks, I'm fine, how about you?</p>

  <p>Johnny: Same here, thanks. So, can you tell us a bit about the software you need us to write?</p>

  <p>Jane: Sure. Recently, I bought a new smartphone as a replacement for my old one. The thing is, I'm really used to the calculator application that was running on the previous phone and I can't find it for my current device.</p>

  <p>Benjamin: Can't you just use another calculator app? There are plenty of them available to download from the web.</p>

  <p>Jane: That's right. I checked them all and none has exactly the same behavior as the one I was using for my tax calculations. You know, the program was like right hand to me and it had some really nice shortcuts that made my life easier.</p>

  <p>Johnny: So you want us to reproduce the application to run on your new device?</p>

  <p>Jane: Yes.</p>

  <p>Johnny: Are you aware that apart from the fancy features that you were using we'll have to allocate some effort to implement the basics that all the calculators have?</p>

  <p>Jane: Sure, I'm OK with that. I'm so used to my calculator application so much that if I use something else for more than few months, I'll have to pay psychotherapist instead of you guys. Apart from that, writing a calculator app seems like a simple task in my mind, so the cost isn't going to be overwhelming, right?</p>

  <p>Johnny: I think I get it. Let's get it going then. We'll be implementing the functionality incrementally, starting with the most essential ones. Which feature of the calculator would you consider the most essential?</p>

  <p>Jane: That would be addition of numbers, I guess.</p>

  <p>Johnny: Ok, that will be our target for the first iteration. After the iteration, we'll deliver this part of functionality for you to try out and give us some feedback. However, before we can even implement addition, we'll have to implement displaying digits on the screen as you enter them. Is that correct?</p>

  <p>Jane: yes, I want the display stuff to work as well - it's the most basic feature, so...</p>

  <p>Johnny: Ok then, this is a simple functionality, so let me suggest some user stories as I understand what you already said and you'll correct me where I'm wrong. Here we go:</p>

  <ol>
    <li><strong>In order to</strong> know that the calculator is turned on, <strong>As a</strong> tax payer <strong>I want</strong> to see "0" on the screen as soon as I turn it on.</li>

    <li><strong>In order to</strong> see what numbers I'm currently operating on, <strong>As a</strong> tax payer, <strong>I want</strong> the calculator to display the values I enter</li>

    <li><strong>In order to</strong> calculate sum of my different incomes, <strong>As a</strong> tax payer <strong>I want</strong> the calculator to enable addition of multiple numbers</li>
  </ol>

  <p>What do you think?</p>

  <p><strong>Jane</strong>: The stories pretty much reflect what I want for the first iteration. I don't think I have any corrections to make.</p>

  <p>Johnny: Now we'll take each story and collect some examples of how it should work.</p>

  <p>Benjamin: Johnny, don't you think it's obvious enough to proceed with implementation straight away?</p>

  <p>Johnny: Trust me, Benjamin, if there's one word I fear most in communication, it's "obvious". Miscommunication happens most often around things that people consider obvious, simply because other people don't.</p>

  <p>Jane: Ok, I'm in. What do I do?</p>

  <p>Johnny: Let's go through stories one by one and see if we can find some key examples of how the features work. The first story is...</p>

  <h3><strong>In order to</strong> know that the calculator is turned on, <strong>As a</strong> tax payer <strong>I want</strong> to see "0" on the screen as soon as I turn it on.</h3>

  <p>Jane: I don't think there's much to talk about. If you display "0", I'll be happy. That's all.</p>

  <p>Johnny: Let's write down this example:</p>

  <table>
    <tr>
      <th>key sequence</th>

      <th>Displayed output</th>

      <th>Notes</th>
    </tr>

    <tr>
      <td>N/A</td>

      <td>0</td>

      <td>Initial displayed value</td>
    </tr>
  </table>

  <p>Benjamin: That makes me wonder... what should happen when I press "0" again at this stage?</p>

  <p>Johnny: Good catch, that's what these examples are for - they make our thinking concrete. As Ken Pugh says: "Often the complete understanding of a concept does not occur until someone tries to use the concept". We'd normally put it on a TODO list, because it's part of a different story, but we're actually done with this one, so let's move straight to the story about displaying entered digits. How about it, Jane?</p>

  <p>Jane: Agree.</p>

  <h3><strong>In order to</strong> see what numbers I'm currently operating on, <strong>As a</strong> tax payer, <strong>I want</strong> the calculator to display the values I enter</h3>

  <p>Johnny: Let's begin with the case raised by Benjamin. What should happen when I input "0" multiple times after I have only "0" on the display?</p>

  <p>Jane: Just one "0" should be displayed</p>

  <p>Johnny: Do you mean this?</p>

  <table>
    <tr>
      <th>key sequence</th>

      <th>Displayed output</th>

      <th>Notes</th>
    </tr>

    <tr>
      <td>0,0,0</td>

      <td>0</td>

      <td>Zero is a special case â€“ it is displayed only once</td>
    </tr>
  </table>

  <p>Jane: That's right. Other than this, the digits should just show on the screen, like this:</p>

  <table>
    <tr>
      <th>key sequence</th>

      <th>Displayed output</th>

      <th>Notes</th>
    </tr>

    <tr>
      <td>1,2,3</td>

      <td>123</td>

      <td>Entered digits are displayed</td>
    </tr>
  </table>

  <p>Benjamin: How about this:</p>

  <table>
    <tr>
      <th>key sequence</th>

      <th>Displayed output</th>

      <th>Notes</th>
    </tr>

    <tr>
      <td>1,2,3,4,5,6,7,1,2,3,4,5,6</td>

      <td>1234567123456?</td>

      <td>Entered digits are displayed?</td>
    </tr>
  </table>

  <p>Jane: Actually, no. My old calculator app has a limit of six digits that I can enter, so it should be:</p>

  <table>
    <tr>
      <th>key sequence</th>

      <th>Displayed output</th>

      <th>Notes</th>
    </tr>

    <tr>
      <td>1,2,3,4,5,6,7,1,2,3,4,5,6</td>

      <td>123456</td>

      <td>Display limited to six digits</td>
    </tr>
  </table>

  <p>Johnny: another good catch, Benjamin!</p>

  <p>Benjamin: I think I'm beginning to understand why you like working with examples!</p>

  <p>Johnny: Good. Is there anything else, Jane?</p>

  <p>Jane: No, that's pretty much it. Let's take another story.</p>

  <h3><strong>In order to</strong> calculate sum of my different incomes, <strong>As a</strong> tax payer <strong>I want</strong> the calculator to enable addition of multiple numbers</h3>

  <p>Johnny: Is the following all we have to support?</p>

  <table>
    <tr>
      <th>key sequence</th>

      <th>Displayed output</th>

      <th>Notes</th>
    </tr>

    <tr>
      <td>2,+,3,+,4,=</td>

      <td>9</td>

      <td>Simple addition of numbers</td>
    </tr>
  </table>

  <p>Jane: This scenario is correct, however, there's also a case when I start with "+" without inputting any number before. This should be treated as adding to zero:</p>

  <table>
    <tr>
      <th>key sequence</th>

      <th>Displayed output</th>

      <th>Notes</th>
    </tr>

    <tr>
      <td>+,1,=</td>

      <td>1</td>

      <td>Addition shortcut â€“ treated as 0+1</td>
    </tr>
  </table>

  <p>Benjamin: How about when the output is a number longer than six digits limit? Is it OK that we truncate it like this?</p>

  <table>
    <tr>
      <th>key sequence</th>

      <th>Displayed output</th>

      <th>Notes</th>
    </tr>

    <tr>
      <td>9,9,9,9,9,9,+,9,9,9,9,9,9,=</td>

      <td>199999</td>

      <td>Our display is limited to six digits only</td>
    </tr>
  </table>

  <p>Jane: Sure, I don't mind. I don't add such big numbers anyway.</p>

  <p>Johnny: There's still one question we missed. Let's say that I input a number, then press "+" and then another number without asking for result with "=". What should I see?</p>

  <p>Jane: Every time you press "+", the calculator should consider entering current number finished and overwrite it as soon as you press any other digit:</p>

  <table>
    <tr>
      <th>key sequence</th>

      <th>Displayed output</th>

      <th>Notes</th>
    </tr>

    <tr>
      <td>2,+,3</td>

      <td>3</td>

      <td>Digits entered after + operator are treated as digits of a new number, the previous one is stored</td>
    </tr>
  </table>

  <p>Jane: Oh, and just asking for result after the calculator is turned on should result in "0".</p>

  <table>
    <tr>
      <th>key sequence</th>

      <th>Displayed output</th>

      <th>Notes</th>
    </tr>

    <tr>
      <td>=</td>

      <td>0</td>

      <td>Result key in itself does nothing</td>
    </tr>
  </table>

  <p>Johnny: Let's sum up our discoveries:</p>

  <table>
    <tr>
      <th>key sequence</th>

      <th>Displayed output</th>

      <th>Notes</th>
    </tr>

    <tr>
      <td>N/A</td>

      <td>0</td>

      <td>Initial displayed value</td>
    </tr>

    <tr>
      <td>1,2,3</td>

      <td>123</td>

      <td>Entered digits are displayed</td>
    </tr>

    <tr>
      <td>0,0,0</td>

      <td>0</td>

      <td>Zero is a special case â€“ it is displayed only once</td>
    </tr>

    <tr>
      <td>1,2,3,4,5,6,7</td>

      <td>123456</td>

      <td>Our display is limited to six digits only</td>
    </tr>

    <tr>
      <td>2,+,3</td>

      <td>3</td>

      <td>Digits entered after + operator are treated as digits of a new number, the previous one is stored</td>
    </tr>

    <tr>
      <td>=</td>

      <td>0</td>

      <td>Result key in itself does nothing</td>
    </tr>

    <tr>
      <td>+,1,=</td>

      <td>1</td>

      <td>Addition shortcut â€“ treated as 0+1</td>
    </tr>

    <tr>
      <td>2,+,3,+,4,=</td>

      <td>9</td>

      <td>Simple addition of numbers</td>
    </tr>

    <tr>
      <td>9,9,9,9,9,9,+,9,9,9,9,9,9,=</td>

      <td>199999</td>

      <td>Our display is limited to six digits only</td>
    </tr>
  </table>

  <p>Johnny: The limiting of digits displayed looks like a whole new feature, so I suggest we add it to the backlog and do it in another sprint. In this sprint, we won't handle such situation at all. How about that, Jane?</p>

  <p>Jane: Fine with me. Looks like a lot of work. Nice that we discovered it up-front. For me, the limiting capability seemed so obvious that I didn't even think it would be worth mentioning.</p>

  <p>Johnny: See? That's why I don't like the word "obvious". Jane, we'll get back to you if any more questions arise. For now, II think we know enough to implement these three stories for you.</p>

  <p>Jane: good luck!</p>

  <h2>Act 3: Test-Driven Development</h2>

  <p>Benjamin: Wow, that was cool. Was that Acceptance Test-Driven Development?</p>

  <p>Johnny: In a greatly simplified version, yes. The reason I took you with me was to show you the similarities between working with customer the way we did and working with the code using TDD process. They're both applying the same set of principles, just on different levels.</p>

  <p>Benjamin: I'm dying to see it with my own eyes. Shall we start?</p>

  <p>Johnny: Sure. If we followed the ATDD process, we'd start writing what we call acceptance-level specification. In our case, however, a unit-level specification will be enough. Let's take the first example:</p>

  <h3>Statement 1: Calculator should display 0 on creation</h3>

  <table>
    <tr>
      <th>key sequence</th>

      <th>Displayed output</th>

      <th>Notes</th>
    </tr>

    <tr>
      <td>N/A</td>

      <td>0</td>

      <td>Initial displayed value</td>
    </tr>
  </table>

  <p>Johnny: Benjamin, try to write the first Statement.</p>

  <p>Benjamin: Boy, I don't know how to start.</p>

  <p>Johnny: start by writing the statement in a plain English. What should the calculator do?</p>

  <p>Benjamin: It should display "0" when I turn the application on.</p>

  <p>Johnny: In our case, "turning on" is creating a calculator. Let's write it down as a method name:</p>
  <pre>
public class CalculatorSpecification
{

[Fact] public void
ShouldDisplay0WhenCreated()
{

}

}
</pre>

  <p>Benjamin: Why is the name of the class <code>CalculatorSpecification</code> and the name of the method <code>ShouldDisplay0WhenCreated</code>?</p>

  <p>Johnny: It's a naming convention. There are many others, but this is the one that I like. The rule is that when you take the name of the class without the <code>Specification</code> part followed by the name of the method, it should form a legit sentence. For instance, if I apply it to what we wrote, it would make a sentence: "Calculator should display 0 when created".</p>

  <p>Benjamin: Ah, I see now. So it's a statement of behavior, isn't it?</p>

  <p>Johnny: That's right. Now, the second trick I can sell to you is that if you don't know what code to start with, start with the expected result. In our case, we're expecting that the behavior will end up as displaying "0", right? So let's just write it in form of an assertion.</p>

  <p>Benjamin: You mean something like this?</p>
  <pre>public class CalculatorSpecification
{

[Fact] public void
ShouldDisplay0WhenCreated()
{
 Assert.Equal("0", displayedResult);
}

}</pre>

  <p>Johnny: Precisely.</p>

  <p>Benjamin: But that doesn't even compile. What use is it?</p>

  <p>Johnny: the code not compiling is the feedback that you needed to proceed. While previously you didn't know where to start, now you have a clear goal - make this code compile. Firstly, whre do you get the displayed value?</p>

  <p>Benjamin: From the calculator display, of course!</p>

  <p>Johnny: Then write it down how you get the value form the display.</p>

  <p>Benjamin: like how?</p>

  <p>Johnny: like this:</p>
  <pre>public class CalculatorSpecification
{

[Fact] public void
ShouldDisplay0WhenCreated()
{
 var displayedResult = calculator.Display();

 Assert.Equal("0", displayedResult);
}

}
</pre>

  <p>Benjamin: I see. Now the calculator is not created anywhere. I need to create it somewhere now or it won't compile and this is my next step. Is this how it works?</p>

  <p>Johnny: Yes, you're catching on quickly.</p>

  <p>Benjamin: Ok then, here goes:</p>
  <pre>public class CalculatorSpecification
{

[Fact] public void
ShouldDisplay0WhenCreated()
{
 var calculator = new Calculator();

 var displayedResult = calculator.Display();

 Assert.Equal("0", displayedResult);
}

}
</pre>

  <p>Johnny: Bravo!</p>

  <p>Benjamin: Now the code still does not compile, because I don't have the <code>Calculator</code> class at all...</p>

  <p>Johnny: sounds like a good reason to create it.</p>

  <p>Benjamin: OK.</p>
  <pre>public class Calculator
{
}
</pre>

  <p>Benjamin: Looks like the <code>Display()</code> method is missing too. I'll add it.</p>
  <pre>public class Calculator
{
  public string Display()
  {
    return "0";
  } 
}
</pre>

  <p>Johnny: Hey hey, not so fast!</p>

  <p>Benjamin: What?</p>

  <p>Johnny: You already provided an implementation that will make our current Statement true. Remember its name? <code>ShouldDisplay0WhenCreated</code> - and that's exactly what the code you wrote does. Before we arrive at this point, let's make sure this Statement can ever be evaluates as false. So for now, let's change it to this:</p>
  <pre>public class Calculator
{
  public string Display()
  {
    return "Once upon a time in Africa...";
  } 
}
</pre>

  <p>Johnny: Look, now we can run the Specification and watch that Statement evaluate to false, because it expects "0", but gets "Once upon a time in Africa...".</p>

  <p>Benjamin: Running... Ok, it's false. By the way, do you always use such silly values to make Statements false?</p>

  <p>Johnny: Hahaha, no, I just did it to emphasize the point. Normally, I'd write <code>return "";</code> or something similarly simple. Now we can evaluate the Statement and see it evaluate to false. Now we are sure that we have not yet implemented what is required for the Statement to be true.</p>

  <p>Benjamin: I think I get it. For now, the Statement shows that we don't have something we need and gives us a reason to add this "thing". When we do so, this Statement will show that we do have what we need. So what do we do now?</p>

  <p>Johnny: Write the simplest thing that makes this Statement true.</p>

  <p>Benjamin: like this?</p>
  <pre>public class Calculator
{
  public string Display()
  {
    return "0";
  } 
}
</pre>

  <p>Johnny: Yes.</p>

  <p>Benjamin: But that's not a real implementation. What's the value behind putting in a hardcoded string? The final implementation is not going to be like this for sure!</p>

  <p>Johnny: You're right. The final implementation is most probably going to be different. What we did, however, is still valuable because:</p>

  <ol>
    <li>You're one step closer to implementing the final solution</li>

    <li>This feeling that this is not the final implementation points you towards writing more Statements. When there is enough Statements to make your implementation complete, it usually means that you have a complete Specification of class behaviors as well.</li>

    <li>If you treat making every Statement true as an achievement, this practice allows you to evolve your code without losing what you already achieved. If by accident you break any of the behaviors you've already implemented, the Specification is going to tell you because one of the existing Statements that were previously true will then evaluate to false. You can then either fix it or undo your changes using version control and start over from the point where all existing Statements were true.</li>
  </ol>

  <p>Benjamin: looks like quite a few benefits. Still, I'll have to get used to this kind of working.</p>

  <p>Johnny: don't worry, it is central to TDD, so you'll grasp it in no time. Now, before we proceed to the next Statement, let's look at what we already achieved. First, we wrote a Statement that turned out false. Then, we wrote just enough code to make the Statement true. Time for a step called Refactoring. In this step, we'll take a look at the Statement and the code and remove duplication. Can you see what's duplicated between the Statement and the code?</p>

  <p>Benjamin: both of them contain the literal "0". The Statement has it here:</p>
  <pre>Assert.Equal("0", displayedResult);</pre>

  <p>and the implementation here:</p>
  <pre>return "0";</pre>

  <p>Johnny: Good, let's eliminate this duplication by introducing a constant called <code>InitialValue</code>. The Statement will now look like this:</p>
  <pre>[Fact] public void
ShouldDisplayInitialValueWhenCreated()
{
 var calculator = new Calculator();

 var displayedResult = calculator.Display();

 Assert.Equal(Calculator.InitialValue, displayedResult);
}
</pre>

  <p>and the implementation:</p>
  <pre>public class Calculator
{
  public const string InitialValue = "0";
  public string Display()
  {
    return InitialValue;
  } 
}
</pre>

  <p>Benjamin: The code looks better and having the constant in one place will make it more maintainable, but I think the Statement in its current form is weaker than before. We could change the <code>InitialValue</code> to anything and the Statement would still be true, since it does not force this constant to be "0".</p>

  <p>That's right. We need to add it to our TODO list to handle this case. Can you write it down?</p>

  <p>Benjamin: Sure. I'll write it as "TODO: 0 should be used as an initial value."</p>

  <p>Johnny: Ok. We should handle it now, especially that it's part of the story we're currently implementing, but I'll leave it for later just to show you the power of TODO list in TDD - whatever is on the list, we can forget and get back to when we have nothing better to do. Our next item from the list is this:</p>

  <h3>Statement 2: Calculator should display entered digits</h3>

  <table>
    <tr>
      <th>key sequence</th>

      <th>Displayed output</th>

      <th>Notes</th>
    </tr>

    <tr>
      <td>1,2,3</td>

      <td>123</td>

      <td>Entered digits are displayed</td>
    </tr>
  </table>

  <p>Johnny: Benjamin, can you come up with a Statement for this behavior?</p>

  <p>Benjamin: I'll try. Here goes:</p>
  <pre>public void [Fact]
ShouldDisplayEnteredDigits()
{
  var calculator = new Calculator();
  
  calculator.Enter(1);
  calculator.Enter(2);
  calculator.Enter(3);
  var displayedValue = calculator.Display();

  Assert.Equal("123", displayedValue);
}
</pre>

  <p>Johnny: I'm glad that you got the part about naming and writing a Statement. One thing we'll have to work on here though.</p>

  <p>Benjamin: what is it?</p>

  <p>Johnny: When we talked to Jane, we used examples with real values. These real values were extremely helpful in pinning down the corner cases and uncovering missing scenarios. They were easier to imagine as well, so they were a perfect suit for conversation. If we were automating these examples on acceptance level, we'd use those real values as well. When we write unit-level Statements, however, we use a different technique to get this kind of specification more abstract. First of all, let me enumerate the weaknesses of the approach you just used:</p>

  <ol>
    <li>Making a method <code>Enter()</code> accept an integer value suggests that one can enter more than one digit at once, e.g. <code>calculator.Enter(123)</code>, which is not what we want. We could detect such cases and throw exceptions if the value is outside the 0-9 range, but there are better ways when we know we'll only be supporting ten digits (0,1,2,3,4,5,6,7,8,9).</li>

    <li>The Statement does not clearly show the relationship between input and output. Of course, in this simple case it's pretty self-evident that the sum is a concatenation of entered digits, we don't want anyone who will be reading this Specification in the future to have to guess.</li>

    <li>The Statement suggests that what you wrote is sufficient for any value, which isn't true, since the behavior for "0" is different (no matter how many times we enter "0", the result is just "0")</li>
  </ol>

  <p>Hence, I propose the following:</p>
  <pre>public void [Fact]
ShouldDisplayAllEnteredDigitsThatAreNotLeadingZeroes()
{
 //GIVEN
 var calculator = new Calculator();
 var nonZeroDigit = Any.Besides(DigitKeys.Zero);
 var anyDigit1 = Any.Of&lt;DigitKeys&gt;();
 var anyDigit2 = Any.Of&lt;DigitKeys&gt;();
          
 //WHEN
 calculator.Enter(nonZeroDigit);
 calculator.Enter(anyDigit1);
 calculator.Enter(anyDigit2);
          
 //THEN
 Assert.Equal(
  string.Format("{0}{1}{2}", 
   (int)nonZeroDigit, 
   (int)anyDigit1, 
   (int)anyDigit2
  ),
  calculator.Display()
 );
}
</pre>

  <p>Benjamin: Johnny, I'm lost! Can you explain what's going on here?</p>

  <p>Johnny: Sure, what do you want to know?</p>

  <p>Benjamin: For instance, what is this <code>DigitKeys</code> type doing here?</p>

  <p>Johnny: It's supposed to be an enumeration (note that it does not exist yet, we just assume that we have it) to hold all the possible digits user can enter, which are 0-9. This is to ensure that user will not write <code>calculator.Enter(123)</code>. Instead of allowing to enter any number and then detecting errors, we're giving our users a choice from among only the valid values.</p>

  <p>Benjamin: Now I get it. So how about the <code>Any.Besides()</code> and <code>Any.Of()</code>? What do they do?</p>

  <p>Johnny: They're methods from a small utility library I'm using when writing unit-level Specifications. <code>Any.Besides()</code> returns any value from enumeration besides the one supplied as an argument. Hence, the call <code>Any.Besides(DigitKeys.Zero)</code> means "any of the values contained in DigitKeys enumeration, but not DigitKeys.Zero".</p>

  <p>The <code>Any.Of()</code> is simpler - it just returns any value in an enumeration. Note that when I create the values this way, I state explicitly that this behavior occurs when first digit is non-zero. This technique of using generated values instead of literals has its own principles, but let's leave it for later. I promise to give you a detailed lecture on it. Agree?</p>

  <p>Benjamin: You better do, because for now, I feel a bit uneasy with generating the values - it seems like the Statement we're writing is getting less deterministic this way. The last question - what about those weird comments you put in the code? Given? When? Then?</p>

  <p>Johnny: Yes, this is a convention that I use, not only in writing, but in thinking as well. I like to think about every behavior in terms of three elements: assumptions (given), trigger (when) and expected result (then). Using the words, we can summarize the Statement we're writing in the following way: "<strong>Given</strong> a calculator, <strong>when</strong> I enter some digits first one being other than zero, <strong>then</strong> they should all be displayed in order they were entered". This is also something that I'll tell you more about later.</p>

  <p>Benjamin: Sure, for now I need just enough detail to understand what's going on - we can talk about the principles, pros and cons later. By the way, the following sequence of casts looks a little bit ugly:</p>
  <pre>  string.Format("{0}{1}{2}", 
   (int)nonZeroDigit, 
   (int)anyDigit1, 
   (int)anyDigit2
  )
</pre>

  <p>Johnny: We'll get back to it and make it more "smarter" in a second after we make this statement true. For now, we need something obvious. Something we know works. Let's evaluate this Statement. What's the result?</p>

  <p>Benjamin: Failed, expected "331", but was "0".</p>

  <p>Johnny: Good, now let's write some code to make this Statement true. First, let's introduce an enumeration of digits:</p>
  <pre>public enum DigitKeys
{
 Zero = 0,
 TODO1, //TODO
 TODO2, //TODO
 TODO3, //TODO
 TODO4, //TODO
}</pre>

  <p>Benjamin: What's with all those bogus values? Shouldn't we just enter all the digits we support?</p>

  <p>Johnny: Nope, not yet. We still don't have a Statement which would say what digits are supported and thus make us add them, right?.</p>

  <p>Benjamin: You say you need a Statement for an element to be in an enum??</p>

  <p>Johnny: This is a specification we're writing, remember? It should say somewhere which digits we support, shouldn't it?</p>

  <p>Benjamin: It's difficult to agree with, especially that I'm used to write unit tests, not Statements and in unit tests, I wanted to verify what I was unsure of.</p>

  <p>Johnny: I'll try to give you more arguments later. For now, just bear with me and note that adding such Statement will be almost effortless.</p>

  <p>Benjamin: OK.</p>

  <p>Johnny: Now for the implementation. Just to remind you - up to now, it looked like this:</p>
  <pre>public class Calculator
{
  public const string InitialValue = "0";
  public string Display()
  {
    return InitialValue;
  } 
}
</pre>

  <p>This is not enough to support displaying multiple digits (as we saw, because the Statement saying they should be supported was evaluated to false). So let's evolve the code to handle this case:</p>
  <pre>public class Calculator
{
 private int _result = 0;
      
 public void Enter(DigitKeys digit)
 {
  _result *= 10;
  _result += (int)digit; 
 }

 public string Display()
 {
  return _result.ToString();
 }
}
</pre>

  <p>Johnny: Now the Statement is true so we can go back to it and make it a little bit prettier. Let's take a second look at it:</p>
  <pre>public void [Fact]
ShouldDisplayAllEnteredDigitsThatAreNotLeadingZeroes()
{
 //GIVEN
 var calculator = new Calculator();
 var nonZeroDigit = Any.Besides(DigitKeys.Zero);
 var anyDigit1 = Any.Of&lt;DigitKeys&gt;();
 var anyDigit2 = Any.Of&lt;DigitKeys&gt;();
          
 //WHEN
 calculator.Enter(nonZeroDigit);
 calculator.Enter(anyDigit1);
 calculator.Enter(anyDigit2);
          
 //THEN
 Assert.Equal(
  string.Format("{0}{1}{2}", 
   (int)nonZeroDigit, 
   (int)anyDigit1, 
   (int)anyDigit2
  ),
  calculator.Display()
 );
}
</pre>

  <p>Johnny: Remember you said that you don't like the part where <code>string.Format()</code> is used?</p>

  <p>Benjamin: Yeah, it seems a bit unreadable.</p>

  <p>Johnny: Let's extract this part into a utility method and make it more general - we'll need a way of constructing expected displayed output in many of our future Statements. Here's my go at this helper method:</p>
  <pre>string StringConsistingOf(params DigitKeys[] digits)
{
 var result = string.Empty;
      
 foreach(var digit in digits) 
 {
  result += (int)digit;
 }
 return result;
}</pre>

  <p>Note that this is more general as it supports any number of parameters. And the Statement after this extraction looks like this:</p>
  <pre>
public void [Fact]
ShouldDisplayAllEnteredDigitsThatAreNotLeadingZeroes()
{
 //GIVEN
 var calculator = new Calculator();
 var nonZeroDigit = Any.Besides(DigitKeys.Zero);
 var anyDigit1 = Any.Of&lt;DigitKeys&gt;();
 var anyDigit2 = Any.Of&lt;DigitKeys&gt;();
          
 //WHEN
 calculator.Enter(nonZeroDigit);
 calculator.Enter(anyDigit1);
 calculator.Enter(anyDigit2);
          
 //THEN
 Assert.AreEqual(
  StringConsistingOf(nonZeroDigit, anyDigit1, anyDigit2),
  calculator.Display()
 );
}
</pre>

  <p>Benjamin: Looks better to me. The Statement is still evaluated as true, which means we got it right, didn't we?</p>

  <p>Johnny: Not exactly. With such moves such as this one, I like to be extra careful. Let's comment out the body of the <code>Enter()</code> method and see if this Statement can still be made false by the implementation:</p>
  <pre>public void Enter(DigitKeys digit)
 {
  //_result *= 10;
  //_result += (int)digit; 
 }
</pre>

  <p>Benjamin: Running... Ok, it is false now. Expected "243", got "0".</p>

  <p>Johnny: good, now we're pretty sure that it works OK. Let's uncomment the lines we just commented out and move forward.</p>

  <h3>Statement 3: Calculator should display only one zero digit if it's the only entered digit even if it is entered multiple times</h3>

  <p>Johnny: Benjamin, this should be easy for you, so go ahead and try it. It's really a variation of previous Statement.</p>

  <p>Benjamin: Let me try... ok, here it is:</p>
  <pre>[Fact] public void 
ShouldDisplayOnlyOneZeroDigitWhenItIsTheOnlyEnteredDigitEvenIfItIsEnteredMultipleTimes()
{
 var zero = DigitKeys.Zero;
 var calculator = new Calculator();
      
 calculator.Enter(zero);
 calculator.Enter(zero);      
 calculator.Enter(zero);
      
 Assert.Equal(
  StringConsistingOf(DigitKeys.Zero), 
  calculator.Display()
 );
}</pre>

  <p>Johnny: Good, you're learning fast! Let's evaluate this Statement.</p>

  <p>Benjamin: It seems that our current code already fulfills the Statement. Should I try to comment some code to make sure this Statement can fail just like you did in the previous Statement?</p>

  <p>Johnny: That would be wise thing to do. When a Statement is true without requiring you to change any production code, it's always suspicious. Just like you said, we have to modify production code for a second to force this Statement to be false, then undo this modification to make it true again. This isn't as obvious as previously, so let me do it. I'll mark all the added lines with <code>//+</code> comment so that you can see them easily:</p>
  <pre>public class Calculator
{
 int _result = 0;
 string fakeResult = "0"; //+
      
 public void Enter(DigitKeys digit)
 {
  _result *= 10;
  _result += (int)digit; 
  if(digit == DigitKeys.Zero) //+
  {  //+
    fakeResult += "0";  //+
  } //+
 }

 public string Display()
 {
  if(_result == 0)  //+
  {  //+
   return fakeResult;  //+
  }  //+
  return _result.ToString();
 }
}</pre>

  <p>Benjamin: Wow, looks like a lot of code just to make the Statement false! Is it worth the hassle? We'll undo this whole modification in a second anyway</p>

  <p>Johnny: Depends on how confident you want to feel. I'd say that it's usually worth it - at least you know that you got everything right. It might seem like a lot of work, but it actually took me about a minute to add this code and imagine you got it wrong and had to debug it on a production environment. _That_ would be a waste of time.</p>

  <p>Benjamin: Ok, I think I get it. Since we saw this Statement turn false, I'll undo this modification to make it true again.</p>

  <p>Johnny: Sure.</p>

  <h2>Epilogue</h2>

  <p>Time to leave Johnny and Benjamin, at least for now. I actually planned to make this chapter longer, and cover all the other operations, but I fear I'd make this too long and get you bored. You should have a feel of how the TDD cycle looks like, especially that Johnny and Benjamin had a lot of conversations on many other topics in the meantime. I'll be revisiting these topics later in the book. For now, so if you felt lost or unconvinced on any of the topics mentioned by Johnny, don't worry - I don't expect you to be proficient with any of the techniques shown in this chapter just yet. Time will come for that.</p>
</body>
</html>

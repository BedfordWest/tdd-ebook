<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title></title>
</head>

<body>
  <h1>Developing TDD style - Constrained Non-Determinism</h1>

  <p>In one of the introductory chapters, I introduced to you the idea of anonymous values generator, which I wrapped in a static class called <code>Any</code>. Throughout the previous chapters I used it quite extensively in many of the Statements I wrote.</p>

  <p>The time has come to explain a little bit more carefully what principles lie under this technique and tool. I'll also use this technique as a case study to show you how one develops a style of Test-Driven Development.</p>

  <h2>A style?</h2>

  <p>Yep. Why am I wasting your time writing about style instead of giving you the hardcore technical details? The answer is simple. Before I started writing this tutorial, I read four or five books solely on TDD and maybe two that contained chapters on TDD. All of this gives about two or three thousands of paper pages, plus numerous posts on many blogs. And you know what I noticed? No two authors use exactly the same sets of techniques for test-driving their code! I mean, sometimes, when you look techniques they're suggesting, the suggestions from two authorities are in contradiction. As each authority has their followers, it's not uncommon to observe and take part in discussions about whether this or that technique is better or leads to trouble.</p>

  <p>I did this, too. I also tried to understand how come people praise techniques I KNEW were wrong and led to disaster. Then, Finally, I got it. I understood that it's not a "technique A vs. technique B" debate. There are certain sets of techniques that work together and choosing one technique leaves us with issues we have to resolve by adopting other techniques. This is how a style is created.</p>

  <p>Developing a style starts with underlying set of principles. These principles lead us to adopt our first technique, which makes us adopt another one and, ultimately, a coherent style emerges. Using Constrained Non-Determinism as an example, I'll try to show you how part of a style gets derived from a technique that is derived from a principle.</p>

  <h2>Principle: tests as specification</h2>

  <p>As I already stressed, I strongly believe that unit tests form a specification. Thus, they should not only pass input values to an object and assert on the output, they should also convey to their reader the rules according to which objects and functions work. The following oversimplified example shows a Statement where it's not explicitly stated what's the relationship between input and output:</p>
  <pre>[Fact] public void 
ShouldCreateBackupFileNameContainingPassedHostName()
{
  //GIVEN
  var fileNamePattern = new BackupFileNamePattern();
  
  //WHEN
  var name = fileNamePattern.ApplyTo("MY_HOST_NAME");
  
  //THEN
  Assert.Equal("backup_MY_HOST_NAME.zip");
}</pre>

  <p>Although the relationship can be guessed quite easily, remember it's just an example. Also, seeing code like that makes me ask questions like: is the "backup_" prefix always applied? What if I actually pass "backup_" instead of "MY_HOST_NAME"? Will the name be "backup_backup_.zip", or "backup_.zip"? Also, is this object responsible for any validation of passed string?</p>

  <p>This makes me invent a first technique to provide my Statements with better support for the principle I believe in.</p>

  <h2>First technique: Anonymous Input</h2>

  <p>I can wrap the actual value "MY_HOST_NAME" with a method hat better documents the constraints required from it by the specified functionality. In our case, we can pass whatever string we want (the object is not responsible for input validation), so we'll name our method <code>AnyString()</code>:</p>
  <pre>[Fact] public void 
ShouldCreateBackupFileNameContainingPassedHostName()
{
  //GIVEN
  var hostName = AnyString();
  var fileNamePattern = new BackupFileNamePattern();
  
  //WHEN
  var name = fileNamePattern.ApplyTo(hostName);
  
  //THEN
  Assert.Equal("backup_MY_HOST_NAME.zip");
}

public string AnyString()
{
  return "MY_HOST_NAME";
}
</pre>

  <p>By doing so, we provide a better documentation of the input value. However, now that the Statement itself is freed from the knowledge of the concrete value of <code>hostName</code> variable, the cocrete value of "backup_MY_HOST_NAME.zip" looks kinda weird. There's no clear indication of the relationship between input and output (one may reason whether the output is always the same string or maybe it depends on the string length). It is unclear which part is added by the code and which one depends on what we pass to the method. This leads us to another technique.</p>

  <h2>Second Technique: Derived Values</h2>

  <p>To better document the relationship between input and output, we have to simply derive the expected value we assert on from the input value. Here's the same Statement with the assertion changed:</p>
  <pre>[Fact] public void 
ShouldCreateBackupFileNameContainingPassedHostName()
{
  //GIVEN
  var hostName = AnyString();
  var fileNamePattern = new BackupFileNamePattern();
  
  //WHEN
  var name = fileNamePattern.ApplyTo(hostName);
  
  //THEN
  Assert.Equal(string.Format("backup_{0}.zip", hostName);
}
public string AnyString()
{
  return "MY_HOST_NAME";
}
</pre>

  <p>This looks more like specification, because we're documenting the format of the backup file name and show which part of the format is variable. This is something you'd probably find documented in a paper specification for the application you're writing - there would probably exist a sentence saying: "The format of a backup file should be <strong>backup_H.zip</strong>, where H is the current local host name".</p>

  <h3>Third technique: Distinct generated values</h3>

  <p>Let's assume that some time after our initial version is shipped</p>
  <pre>[Fact] public void 
ShouldCreateBackupFileNameContainingPassedHostName()
{
  //GIVEN
  var hostName = AnyString();
  var userName = AnyString();
  var fileNamePattern = new BackupFileNamePattern();
  
  //WHEN
  var name = fileNamePattern.ApplyTo(hostName, userName);
  
  //THEN
  Assert.Equal(string.Format(
    "backup_{0}_{1}.zip", hostName, userName);
}

public string AnyString()
{
  return "MY_HOST_NAME";
}
</pre>
  <pre>[Fact] public void 
ShouldCreateBackupFileNameContainingPassedHostName()
{
  //GIVEN
  var hostName = AnyString();
  var userName = AnyString();
  var fileNamePattern = new BackupFileNamePattern();
  
  //WHEN
  var name = fileNamePattern.ApplyTo(hostName, userName);
  
  //THEN
  Assert.Equal(string.Format(
    "backup_{0}_{1}.zip", hostName, userName);
}

public string AnyString()
{
  return Guid.NewGuid.ToString();
}
</pre>

  <h2>Distinct values</h2>

  <h2>Helps in specification rather than testing.</h2>

  <h2>emphasis on specification and derived values</h2>

  <h2>Don't care values</h2>

  <h2>Documentation on constraints</h2>

  <p>Any can be understood as just one of the possible ways to implement what Gerard Meszaros calls Anonymous Creation Method (http://xunitpatterns.com/Creation%20Method.html#Anonymous%20Creation%20Method). AutoFixture may be used as another, although it's far more powerful (and its author suggests that it's an implementation of Test Data Builder pattern: http://nat.truemesh.com/archives/000714.html although the API of AutoFixture is quite different than what you can find in hand-written Test Data Builder - it relies more on reflection and automation). Understood as such, the goal of the Any is a creation of distinct value and free us from thinking what values to give to our variables. For example, let's say that we invoke in test a method that takes three integers and specify that it should call a method of another object with the third of the integers as parameters. Using Any, I don't have to think about the values, just type:</p>
  <pre>var int1 = Any.Integer();
var int2 = Any.Integer();
var int3 = Any.Integer();</pre>

  <p>and I know the values are distinct (note that "distinct" does not exactly mean "random" - AutoFixture for example applies certain algorithms for generating different data types). It isn't as good for booleans, of course :-), but what can one do...</p>

  <p>On the other hand, Any can be understood as just one of the possible implementations of Constrained Non-Determinism principle (see http://blog.ploeh.dk/2009/03/05/ConstrainedNon-Determinism/). As such, one of its purposes is to think on a little bit higher level of abstraction and avoid too much triangulation where it isn't necessary, Also, it helps use derived values as an alternative to hardcoded values. for simplest example, let's assume that we're test-driving a logic to merge two segments of a file path, e.g. "C:" and "Windows" becomes "C:\\Windows". It's tempting to write:</p>
  <pre>var segment1 = "C:";
var segment2 = "Windows";
var expectedPath = "C:\\Windows";

Assert.AreEqual(expectedPath, MyPath.Combine(segment1, segment2));
</pre>

  <p>Here, it's quite simple, however the point is that the relationship between input and output is not clear, hence the value of the test as living documentation is a little bit lower. Thus, we may choose to do the following:</p>
  <pre>var segment1 = Any.String();
var segment2 = Any.String();
var expectedPath = segment1 + "\\" + segment2;

Assert.AreEqual(expectedPath, MyPath.Combine(segment1, segment2));</pre>

  <p>Here, not only do we document the relationship between input and output, we also document the constraints on the input. Note that by stating that segment can be any string, I indirectly state that there are no constraints on the value - method does not check whether the segments are correct in terms of this or that filesystem. This is useful in documenting how much domain-related cohesion does the object itself enforce on its arguments.</p>

  <p>Thinking in terms of constraints is also useful when doing the analysis step of TDD. Let's say that we need an integer variable and assign Any.Integer() to it. Then, we hesitate for a second and think: "well, actually, this can't be any integer, because when I enter 0, the behavior is going to be different... That leads us to the conclusion that we might have a missing test to write. In other words, it's useful to think of the range of the values a behavior should support to find out missing behaviors. As funny as it is, it's precisely opposite to what we do on acceptance level. Ken Pugh, Gojko Adzic, Dan North, Liz Keogh all suggest that when we're specifying on acceptance level, we should use real values and these values should come from the domain (i.e. be values that a real user could use) - then, scenarios with such real values are also more readable to the customer. I don't know why I like "Any" better on the unit level - maybe because on acceptance level I try more to understand the world of my customers and how they use the system and real values help me with that. On the other hand, on unit level I test-drive the design and there, thinking in terms of abstract "classes of equivalence" helps me identify paths through methods and objects? I don't know, gotta think about it :-).</p>
</body>
</html>

<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Test-Driven Development - Extensive Tutorial</title>
  <link href="../Styles/Global.css" rel="stylesheet" type="text/css"/>
</head>

<body>
  <h1>On Objects Composability</h1>

  <p>In this chapter, I will try to outline why objects' composability is a goal worth achieving and how it can be achieved. I am going to start with an example of unmaintainable code and will gradually fix its flaws in the next chapters. In this chapter, we are going to fix just one of the flaws, so the code we will end up will not be perfect by any means, still, it will be better by one quality.</p>

  <h1 id="u303f0ca0-6691-42d4-8868-4c04aa39a43b">TODO make it into a role-play!</h1>

  <h1 id="u1b304157-2049-4846-92dc-f3500e72432e">Another task for Johnny and Benjamin</h1>

  <p>Remember Johnny and Benjamin? Looks like they managed their previous task and are up to something else. Let us listen to their conversation as they are working on another project...</p>

  <p><strong>Benjamin:</strong> So, what's this assignment about?</p>

  <p><strong>Johnny:</strong> Actually, it's nothing exciting - we'll have to add two features to a legacy application that's not prepared for the changes.</p>

  <p><strong>Benjamin:</strong> What is the code for?</p>

  <p><strong>Johnny:</strong> It is a class that implements company policies. As the company has just started using this automated system and it was started recently, there is only one policy implemented: yearly incentive plan. Many corporations have what they call incentive plans. These plans are used to promote good behaviors and exceeding expectations by employees of a company.</p>

  <p><strong>Benjamin:</strong> You mean, the project has just started and is already in a bad shape?</p>

  <p><strong>Johnny:</strong> Yep. The guys writing it wanted to "keep it simple", whatever that means, and now it looks pretty bad.</p>

  <p><strong>Benjamin:</strong> I see...</p>

  <p><strong>Johnny:</strong> By the way, do you like riddles?</p>

  <p><strong>Benjamin:</strong> Always!</p>

  <p><strong>Johnny:</strong> So here's one: how do you call a development phase when you ensure high code quality?</p>

  <p><strong>Benjamin:</strong> ... ... seems I don't have a clue... So what is it called?</p>

  <p><strong>Johnny:</strong> It's called "now".</p>

  <p><strong>Benjamin:</strong> Oh!</p>

  <p><strong>Johnny:</strong> By the way, the company's incentive plan is one of the most stupid ones I've ever seen. Wonder how this company has managed to stay on the market for three years.</p>

  <p>Every employee in the company has a pay grade. An employee can be promoted to a higher pay grade, but the mechanics of how it works is something we are not going to deal with.</p>

  <p>Normally, every year, everyone gets a raise by 10%. But to encourage behaviors that give an employee a higher pay grade, such employee cannot get raises indefinitely on a given pay grade. Each grade has its associated maximum pay. If this amount of money is reached, an employee does not get a raise anymore until they reach a higher pay grade.</p>

  <p>Additionally, every employee on their 5th anniversary of working for the company, gets a special, one-time bonus which is twice their current payment.</p>

  <p><strong>Benjamin:</strong> Looks like the source code repository just finished synchronizing. Let's take a bite at the code!</p>

  <p><strong>Johnny:</strong> Sure, here you go:</p>
  <pre>public class CompanyPolicies : IDisposable
{
  readonly SqlRepository _repository
    = new SqlRepository();
  
  public void ApplyYearlyIncentivePlan()
  {
    var employees = _repository.CurrentEmployees();

    foreach(var employee in employees)
    {
      var payGrade = employee.GetPayGrade();
      //evaluate raise
      if(employee.GetSalary() &lt; payGrade.Maximum)
      {
        var newSalary 
          = employee.GetSalary() 
          + employee.GetSalary() 
          * 0.1;
        employee.SetSalary(newSalary);
      }
      
      //evaluate one-time bonus
      if(employee.GetYearseOfService() == 5)
      {
        var oneTimeBonus = employee.GetSalary() * 2;
        employee.SetBonusForYear(2014, oneTimeBonus);
      }
      
      employee.Save();
    }
  }
  
  public void Dispose()
  {
    _repository.Dispose();
  }
}</pre>

  <p><strong>Benjamin:</strong> Wow, there is a lot of literal constants all around and functional decomposition is barely done!</p>

  <p><strong>Johnny:</strong> Yeah. We won't be fixing all of that today. Still, we will follow the scout rule and "leave the campground cleaner than we found it".</p>

  <p><strong>Benjamin:</strong> What's our assignment?</p>

  <p><strong>Johnny:</strong> First of all, we need to provide our users a choice between an SQL database and a NoSQL one. To achieve our goal, we need to be somehow able to make the <code>CompanyPolicies</code> class database type-agnostic. For now, as you can see, the implementation is coupled to the specific <code>SqlRepository</code>, because it creates a specific instance itself:</p>
  <pre>public class CompanyPolicies : IDisposable
{
  readonly SqlRepository _repository
    = new SqlRepository();
</pre>

  <p>Now, we need to evaluate the options we have to pick the best one. What options do you see, Benjamin?</p>

  <p><strong>Benjamin:</strong> Well, we could certainly extract an interface from <code>SqlRepository</code> and introduce an if statement to the constructor like this:</p>
  <pre>public class CompanyPolicies : IDisposable
{
  readonly Repository _repository;

  public CompanyPolicies()
  {
    if(...)
    {
      _repository = new SqlRepository();
    }
    else
    {
      _repository = new NoSqlRepository();
    }
  }
</pre>

  <p><strong>Johnny:</strong> True, but this option has few deficiencies. First of all, remember we're trying to follow the scout rule and by using this option we introduce more complexity to the CommonPolicies class. Also, let's say tommorow someone writes a class for reporting - they will need to make the same decision on repositories. This means we would have to make the same decision in both of these classes, effectively duplicating code. What's our next option?</p>

  <p><strong>Benjamin:</strong> Another option would be to change the SqlRepository itself to be just a wrapper around the actual database access, like this:</p>
  <pre>public class SqlRepository : IDisposable
{
  readonly Repository _repository;

  public SqlRepository()
  {
    if(...)
    {
      _repository = new RealSqlRepository();
    }
    else
    {
      _repository = new RealNoSqlRepository();
    }
  }

  IList&lt;Employee&gt; CurrentEmployees()
  {
    return _repository.CurrentEmployees();
  }
</pre>

  <p><strong>Johnny:</strong> Sure, this is an approach that could work and would be worth considering for very serious legacy code, as it does not force us to change the <code>CompanyPolicies</code> class. However, there are some issues with it. First of all, the <code>SqlRepository</code> name would be misleading. Second, look at the <code>CurrentEmployees()</code> method - all it does is delegating a call to the implementation chosen in the constructor. With every new method required of the repository, we'll need to add new delegating methods. It isn't such a big deal, but maybe we can do better than that?</p>

  <p><strong>Benjamin:</strong> Let me think, let me think... OK, got it! We could use polymorphism! All we need to do is extract an interface from the <code>SqlRepository</code>, let's call it <code>Repository</code>, and then, instead of creating a repository instance in <code>CompanyPolicies</code> like this:</p>

  <pre>public class CompanyPolicies : IDisposable
{
  private readonly SqlRepository _repository
    = new SqlRepository();
 </pre>

<p>just pass an instance through the constructor, like this:</p>

  <pre>public class CompanyPolicies : IDisposable
{
  private readonly Repository _repository;

  public CompanyPolicies(Repository repository)
  {
    _repository = repository;
  }
 </pre>

<p>This way, the <code>CompanyPolicies</code> won't know what exactly is passed to it via constructor and we can pass whatever we like - either an SQL repository or a NoSQL one!</p>

<p><strong>Johnny:</strong> Great! This is the option we're looking for! For now, just believe me that this approach will lead us to many good things - later, you'll see for yourself.</p>

  <p><strong>Benjamin:</strong> OK, so let me just pull the <code>SqlRepository</code> outside the class and make it an implementation of <code>Repository</code> interface, than create a constructor and pass the real instance through it...</p>

  <pre>public class CompanyPolicies : IDisposable
{
  //_repository is now an interface
  readonly Repository _repository; 

  //New constructor
  public CompanyPolicies(Repository repository)
  {
    _repository = repository;
  }
  
  public void ApplyYearlyIncentivePlan()
  {
    //... body of the method. hidden for now
  }
  
  public void Dispose()
  {
    _repository.Dispose();
  }
}</pre>

  <p><strong>Benjamin:</strong> Ha ha! Look at this! I am SUPREME!</p>

<p><strong>Johnny:</strong> Hey, hey, hold your horses! There is one thing wrong with this code.</p>

  <p><strong>Benjamin:</strong> Huh? I thought this is what we were aiming at.</p>

  <p><strong>Johnny:</strong> Yes, with the exception of the <code>Dispose()</code> method. Look closely at the <code>CompanyPolicies</code> class. it is changed so that it is not responsible for creating a repository for itself, but it still disposes of it. This is wrong because <code>CompanyPolicies</code> instance does not have any right to assume it is the only object that is using the repository.</p>

  <p><strong>Benjamin:</strong> Ok, I get the theory, but why is this bad in practice? Can you give me an example?</p>

  <p><strong>Johnny:</strong> Sure. As soon as you have two instances of <code>CompanyPolicies</code> class, both sharing the same instance of <code>Repository</code>, you're cooked. This is because one instance of <code>CompanyPolicies</code> may dispose of the repository and the other one may still use it.</p>

  <p><strong>Benjamin:</strong> So who is going to dispose of the repository?</p>

<p><strong>Johnny:</strong> The same place in the code that created it. Let me show you an example:</code>

<pre>
public static void Main(string[] args)
{
  using(var repo = new SqlRepository())
  {
    var policies = new CompanyPolicies(repo);

    //use policies for anything you like
  }
}
</pre>

<p>This way the repository is created at the start of the program and disposed at the end. Thanks to this, the <code>CompanyPolicies</code> has no disposable fields and it itself does not have to be disposable - we can just delete the <code>Dispose()</code> method:</p>
</pre>

<pre>//not implementing IDisposable anymore:
public class CompanyPolicies 
{
  //_repository is now an interface
  readonly Repository _repository; 

  //New constructor
  public CompanyPolicies(Repository repository)
  {
    _repository = repository;
  }
  
  public void ApplyYearlyIncentivePlan()
  {
    //... body of the method. hidden for now
  }

  //no Dispose() method anymore
}</pre>

<p><strong>Benjamin:</strong> Cool. So, what now? Seems we have the <code>CompanyPolicies</code> class depending on repository abstraction instead of an actual implementation, like SQL repository. My guess is that we will be able to make another class implementing the interface for NoSQL data access and just pass it through the constructor instead of the original one.</p>

<p><strong>Johnny:</strong> Yes. Speaking in other words, if we have two implementations of the same interface and can pass either to be used a piece of code without having to change this piece of code, we can say that we have achieved composability of those components. </code>

<p><strong>Benjamin:</strong> Composability?</p>

<p><strong>Johnny:</strong> Yes. It's a bit of theory, but in my mind it is crucial to understand it to build maintainable systems. For example, look at <code>CompanyPolicies</code> component. We can compose it with a repository like this:</p>

<pre>var policies 
  = new CompoanyPolicies(new SqlRepository());</pre>

<p>or like this:</p>

<pre>var policies 
  = new CompoanyPolicies(new NoSqlRepository());</pre>

<p>which means that <code>CompanyPolicies</code> does not need to know what <code>Repository</code> exactly it is composed with, as long as this <code>Repository</code> follows the required interface and meets expectations of <code>CompanyPolicies</code>. An implementation of <code>Repository</code> may be itself a very complex</p>




  <h1 id="u0b534e02-c756-4dd3-8987-289aecf54d18">TOOOOOOOOOOOODOOOOOOOOOO</h1>

  <p>There are a couple of ways of dealing with this problem, like:</p>

  <h1 id="u6e123cb8-1045-4908-9fbb-9b4bbc58dbe8">TOOOOOOOOOODOOOOOOOOO convert the list to separate sections</h1>

  <ol>
    <li>Creating a constructor with an if statement inside to choose the database - this is a bad idea because other classes in our system use the database as well so the if statement will need to be duplicated.</li>

    <li>Changing the <code>SqlRepository</code> class itself so that it hides the information on the database used behind its own API - this could work, but will lead to every method duplicating the choice between the databases. If we decide to make the choice just once, we don't really need this class, because most of the time it will delegate to its inner implementation.</li>

    <li>Extract interface and pass either of its two implementations through the constructor.</li>
  </ol>

  <p>The third options seems to be the most compelling, so let us put it to use. We can extract an interface from <code>SqlRepository</code>, called <code>EmployeeSource</code> (TODO why this name?) and pass an instance from outside of the class:</p>
  <pre>public class CompanyPolicies : IDisposable
{
  readonly EmployeeSource _employeeSource;  

  public CompanyPolicies(EmployeeSource source)
  {
    _employeeSource = source;
  }
  
  //...code  
  
  public void Dispose()
  {
    _employeeSource.Dispose();
  }
}</pre>

  <p>The <code>CompanyPolicies</code> is used in the code the following way:</p>
  <pre>
var policies = new CompanyPolicies(new SqlRepository());

//... somewhere else in the code

policies.ApplyYearlyIncentivePlan();

//... somewhere else in the code

policies.Dispose();
</pre>

  <p>Note two things: 1) as the employee source instance is passed by 3rd party, <code>CompanyPolicies</code> instances cannot assume the instance is used only by itself. Thus, it cannot neither initialize nor dispose of the instance. These two responsibilities have to be moved outside the class as well:</p>
  <pre>public class CompanyPolicies
{
  readonly EmployeeSource _employeeSource;  

  public CompanyPolicies(EmployeeSource source)
  {
    _employeeSource = source;
  }
  
  public void ApplyYearlyIncentivePlan()
  {
    var employees = _repository.CurrentEmployees();

    foreach(var employee in employees)
    {
      var payGrade = employee.GetPayGrade();
      if(employee.GetSalary() &lt; payGrade.Maximum)
      {
        var newSalary 
          = employee.GetSalary() 
          + employee.GetSalary() 
          * 0.1;
        employee.SetSalary(newSalary);
      }
      
      if(employee.GetYearseOfService() == 5)
      {
        var oneTimeBonus = employee.GetSalary() * 2;
        employee.SetBonusForYear(2014, oneTimeBonus);
      }

      employee.Save();
    }
  }
}</pre>

  <p>Note that we got rid of IDisposable, which is always good for abstraction... Now the usage pattern looks the same, only that now the same third party that created employees object, disposes of it. This is good, because one object has complete control over the lifetime of the employees object:</p>
  <pre>SqlRepository repository = new SqlRepository();
var policies = new CompanyPolicies(repository);

//... somewhere else in the code

policies.ApplyYearlyIncentivePlan();

//... somewhere else in the code

repository.Dispose();
</pre>

  <p>What have we achieved? Well, we allowed ourselves to choose the implementation of employees' storage. We did this by making the system composable - i.e. we can achieve different behaviors of the system by changing the way objects are composed together into a system. For example, instead of creating a <code>policies</code> object like this:</p>
  <pre>SqlRepository repository = new SqlRepository();
var policies = new CompanyPolicies(repository);</pre>

  <p>we can create it like this:</p>
  <pre>NoSqlRepository repository = new NoSqlRepository();
var policies = new CompanyPolicies(repository);</pre>

  <p>Or even, if we later decide to make the repository configurable by a strategy (e.g. there may be different definitions of what it means to get "current" employees) and extract the connection logic even further and make error reporting more configurable, we can do it like this:</p>
  <pre>Repository repository = new RepositoryConfigurableByPolicies(
  new SqlDatabase(),
  new FilterToExcludeProbationEmployeesFromCurrent(),
  new ErrorReportingToLogFile()
);
var policies = new CompanyPolicies(repository);</pre>

  <p>Everything without touching the <code>CompanyPolicies</code> class. Now, let us take the <code>ErrorReportingToLogFile</code> class and assume, that it is passed where an interface is required. We can, again, exchange this to something else, e.g.:</p>
  <pre>Repository repository = new RepositoryConfigurableByPolicies(
  new SqlDatabase(),
  new FilterToExcludeProbationEmployeesFromCurrent(),
  new ErrorReportingThroughNetwork());
);</pre>

  <p>Or make it configurable itself, e.g. with different formats and flushing algorithms (for performance purposes):</p>
  <pre>Repository repository = new RepositoryConfigurableByPolicies(
  new SqlDatabase(),
  new FilterToExcludeProbationEmployeesFromCurrent(),
  new ErrorReportingToLogFile(
    new XmlLogFormat(),
    new FlushingDelayedUntilCachedContentIsMoreThan(
      Kilobytes.Value(5)
    )
  )
);</pre>

  <p>Again, these modifications are all possible without touching the <code>RepositoryConfigurableByPolicies</code> class!</p>

  <h1 id="u043cb06f-db76-4bf9-9af2-8b2b80645c84">Todo write about web of objects and how we can unplug parts of the web and plug in different parts to modify the system behavior without modifying the rest of the web</h1>

  <h1 id="u981e4959-b272-498b-9e37-d6d16512974d">Todo write about composition root!</h1>
</body>
</html>
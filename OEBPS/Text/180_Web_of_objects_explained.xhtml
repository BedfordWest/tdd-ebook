<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Web of objects explained</title>
        <link href="../Styles/Global.css" rel="stylesheet" type="text/css"/>
    </head>
    <body>

<h1>The need for mock objects</h1>

<p>We experienced mock objects in the chapter about tools, although at that point, I gave you an oversimplified and deceiving explanation of what a mock object is, promising that I will make up for it later. Now is the time.</p>

<p>Mock objects were made with specific goal in mind. In my mind, without understanding the real goal, you will probably misunderstand the means to the goal.</p>

<p>In this chapter, we will explore the qualities of object oriented design which make mock objects a viable tool.</p>

<h1>Composability... again!</h1>

<p>In the two previous chapters, we followed Johnny and Benjamin in discovering the benefits of and prerequisites for composability of objects. Actually, composability is number one quality of the design we're after. After reading Johhny and Benjamin's story, you might have some questions regarding composability. Hopefully, they are among these:</p>


<h2>What does it mean to compose objects?</h2>

<p>Basically it means that an object has obtained a reference to another object and is invoking methods on it. By being composed together, two objects form a small system that can be expanded with more objects. Thus, an object oriented system forms a web:</p>

<p>TOOOODOOO: web of objects</p>

<p>TOOOODOOO message passing, network etc.</p>

<p>TOOOODOOO definitions of sender and recipient.</p>

<h2>Why do we need composability?</h2>

<p>TOOOOOOOOOOODOOO substitute classes</p>

<h2>How are objects composed?</h2>

<p>There are various ways to compose two objects depending on how a reference to an object is obtained and how long the composition lasts.</p>

<h3>Constructor</h3>

<p>Two objects can be composed by passing one into the constructor of another:</p>

<pre>sender = new Sender(recipient);</pre>

<p>Here, a sender is composed with a recipient and stores a reference to the recipient in a private field, like this:</p>

<pre>public Sender(Recipient recipient)
{
  this._recipient = recipient;
}</pre>

<p>The code that performs this composition is most often in a totally different place than the client code calling methods on the <code>Sender</code>. Thus, this client code does not need to know that such a composition took place. The existence of <code>Recipient</code> is hidden from it. This basically means that in the implementation of the following call:</p>

<pre>sender.DoSomething()</pre>

<p><code>Sender</code> may send message to <code>Recipient</code> internally, but the code invoking the <code>DoSomething()</code> method is completely unaware of that.</p>

<p>Constructor is a great way to compose sender with a recipient permanently. In order to be able to do this, a <code>Recipient</code> must, of course, exist before a <code>Sender</code> does. Another less obvious requirement for this composition is that <code>Recipient</code> must be usable at least as long as <code>Sender</code> is usable. In other words, the following is nonsense:</p>

<pre>sender = new Sender(recipient);
recipient.Dispose(); //but sender is unaware and may still use recipient:
sender.DoSomething();</pre>

<h3>Method parameter</h3>

<p>Another common way of composing objects together is passing one object as a parameter of another object's method call:</p>

<pre>sender.DoSomethingTo(recipient);</pre>

<p>Here, the objects are most often composed temporarily, just for this single method.</p>

<p>This is a great way to compose objects when we want to use the same sender with different recipients at different times (most often from different parts of the code).</p>

<h3>Factories</h3>

<p>This method of composing objects uses another intermediary object - a factory. In other words, the sender is first composed with a factory via constructor:</p>

<pre>sender = new Sender(factory);</pre>

<p>and then the factory is used to deliver other objects:</p>

<pre>public class Sender
{
  //...

  public DoSomething() 
  {
    recipient = _factory.CreateRecipient();
    recipient.DoSomethingElse();
  }
}</pre>

<p>This kind of composition is beneficial when a different recipient is needed each time <code>DoSomething()</code> is called, but at the same time, contrary to passing recipient as a method parameter, the client should not (or cannot) be responsible for supplying a recipient.</p>

<h2>Weaker and better composability</h2>

<p>Some classes are harder to compose with other classes, others are easier. There are numerous factors influencing this:</p>

<h3>Classes vs interfaces</h3>

<p>As we said, an object is composed with another object by obtaining a reference to something. Also, we said that we want the flexibility of plugging in objects of different classes at different times. This is, of course, done using polymorphism, as Johnny and Benjamin did when cleaning up the payroll system. So, what should be the base for polymorphism? Is a class sufficient, or do we rather want to use an interface? In other words, when we plug in an object as a message receipient:</p>

<pre>public Sender(Recipient recipient)
{
  this._recipient = recipient;
}</pre>

<p>Should the Recipient be a class or an interface?</p>

<p>If we assume that Recipient is a class, we can get the composability we want by deriving another class from it and overriding methods. However, using a class as a base for composability has the following weaknesses:</p>

<ol>
  <li>The superclass may have real dependencies. For example, if <code>Recipient</code> class depends on WCF stack, then everywhere we take our Sender to compose it with different recipients, we must also take our <code>Recipient</code> and its WCF dependency.</li>
  <li>We force each recipient class we want to compose our sender with to invoke a constructor from superclass, which, depending on the complexity of the superclass, may be smaller or bigger trouble.</li>
  <li>In languages like C#, when only single inheritance exists all the classes that want to be composed with our <code>Sender</code>, we waste the only inheritance slot, further constraining the inheriting classes.</li>
  <li>We must take care to make all methods of <code>Recipient</code> superclass virtual to enable overriding by subclasses. otherwise, we won't have full composability.</li>
</ol>

<p>As you see, there are some difficulties using classes as "slots for composability", even if composition is possible this way. Thus, interfaces are far better, just because they are easier to use for this purpose.</p>

<p>It is decided then, If a sender wants to be composable with recipient, it has to accept a reference to recipient in form of interface reference. We can say that, by being light-weight and implementationless, <strong>interfaces can be treated as "slots" for plugging in different objects</strong>.</p>

<p>In fact, when we look at how interfaces are depicted on UML class diagrams, it seems that the "interface as slot for composition" notion is not unusual:</p>

<p>TODO insert a picture showing one notation of interfaces in UML.</p>

<p>It is just that we try to take the notion of composability to its fullest, as not only a first-class citizen, but as THE most important aspect of our design approach.</p>

<h3>Events vs interfaces</h3>

<p>TODO TODO TODO TODO</p>

<h3>Small interfaces</h3>

<p>Ok, so we said that he interfaces are "the way to go" for reaching the strong composability we're striving for. Is it enough just to "have interfaces"? No, actually, it's not.</p>

<p>One of the other things we need to consider is the size of interfaces. Let's state one thing that is obvious in regard to this:</p>

<p><strong>All other things equal, smaller interfaces are easier to implement that bigger interfaces.</strong></p>

<p>The obvious conclusion from this is that if we want to have really strong composability, our "slots", i.e. interfaces, have to be as small as possible. Of course, we cannot achieve this by removing methods that are needed from the interfaces, e.g. when someone is using an interface implementation like this:</p>

<pre>recipient.SomethingHappened();
recipient.SomethingElseHappened();</pre>

<p>It is impossible to just remove either method from the interface, or the client will stop compiling.</p>

<p>So, what do we do then? We try to separate different interfaces per client. After all, a class can implement more than one interface, like this:</p>

<pre>public class ImplementingObject 
: InterfaceForClient1, 
  InterfaceForClient2,
  InterfaceForClient3
{ ... }</pre>

<p>This notion of using a separate interface per client and not one bigger interface for different clients is known as the Interface Segregation Principle.</p>

<h4>A simple example: separation of reading from writing</h4>

<p>For example, we may have a class representing organizational structure in our application. On one hand, the application is notified on any changes that are made from administration interface. On the other hand, it supports client-side operations for ordinary users, e.g. listing all users. The interface for this organizational structure class may look like this:</p>

<pre>public interface 
OrganizationStructure
{
  //administrative part:
  void Make(Change change);
  
  //client-side part:
  void ListAllEmployees(
    EmployeeDestination destination);
}</pre>

<p>but, most certainly, the two sets of methods will be used by different code - one related to handling administrative requests, another related to handling ordinary user requests. Thus, we can use this knowledge to separate the interface into two:</li>

<pre>public interface
OrganizationalStructureAdminCommands
{
  void Make(Change change);
}

public interface
OrganizationalStructureClientCommands
{
  void ListAllEmployees(
    EmployeeDestination destination);
}</pre>

<p>And a real class can implement both of them:</p>

<pre>public class InMemoryOrganizationalStructure
: OrganizationalStructureAdminCommands,
  OrganizationalStructureClientCommands
{
  //...
}</pre>
<p>Sure, there are more interfaces, but that doesn't bother us much, because in return, each interface is easier to implement. In other words, it is easier to make new implementations we can compose users of those interfaces with. This means that composability is enhanced, which is what we want the most. After all, nobody said there will always be a single class implementing both interfaces. One day, we maye get a requirement that all writes to the organizational structure have to be traced. In such case, All we have to do is to create new class implementing <code>OrganizationalStructureAdminCommands</code> which will wrap the original method with a notification to a change observer (that can be either the trace that is required or anything else we like):</p>

<pre>public class NotifyingAdminComands : OrganizationalStructureAdminCommands
{
  public NotifyingCommands(
    OrganizationalStructureAdminCommands wrapped,
    ChangeObserver observer)
  {
    _wrapped = wrapped;
    _observer = observer;
  }

  void Make(Change change)
  { 
    _wrapped.Make(change);
    _observer.NotifyAbout(change);
  }
}</pre>

<p>If we did not separate interfaces for admin and client access, in our <code>NotifyingAdminComands</code> class, we would have to implement the <code>ListAllEmployees</code> method and make it delegate to the original wrapped instance. Splitting the interface into two smaller ones spared us this trouble.</p>

<h3>Protocols</h3>

<p>So, we said that objects are connected (composed) together and communicate through interfaces, just as in IP network. There is another similarity though, that's as important. It's protocols.</p>

<h4>Protocols exist</h4>

<p>I do not want to introduce any scientific definition, so let's just establish an understanding that protocols are sets of rules about how objects communicate with each other. Really? Are there any rules? Is it not enough the the objects can be composed together through interfaces? Well, not, it's not enough and let me give you a quick example.</p>

<p>Let us imagine a class <code>Sender</code> that uses <code>Recipient</code> like this:</p>

<pre>if(recipient.ExtractStatusCodeFrom(response) == -1)
{
  observer.NotifyErrorOccured();
}</pre>

<p>Stupid as it is, the example shows one important thing. Whoever the recipient is, it is expected to report error as -1. Otherwise, the <code>Sender</code> will not be able to react to the error situation appropriately. Similarly, the recipient must not report "no error" situation as -1, because if it does, this will be mistakenly recognized as error by <code>Sender</code>. So for example this implementation of <code>Recipient</code>, although implementing the required interface, is wrong from the point of view of <code>Sender</code>:</p>

<pre>public class WrongRecipient : Recipient
{
  public int ExtractStatusFrom(Response response)
  {
    if( /* success */ )
    {
      return -1; // but other than -1 should be used!
    }
    else
    {
      return 1; // -1 should be used!
    }
  }
}</pre>

<p>So as you see, we cannot just write anything in a class implementing an interface, because of protocol that imposes certain contract on both the sender and recipient. This contract may not only be about return values, it can also be on types of exceptions thrown, or the order of method calls. For example, anybody using some kind of connection object would imagine the following way of using the connection:</p>

<pre>connection.Open();
connection.Send(data);
connection.Close();</pre>

<p>Again, if we were to implement a connection that behaves like this:</p>

<pre>public class WrongConnection : Connection
{
  public void Open()
  {
    //...close connection
  }

  public void Close()
  {
    //...open connection
  }
}</pre>

<p>it would compile just fine, but fail badly when executed.</p>

<p>So, again, there are certain rules that restrict the way two objects can communicate. Both sender and recipient of a message must adhere to the rules, or the they will not be able to work together.</p>

<p>The good news is that WE are the ones who design these protocols, along with the interfaces, so we can design them to be harder or easier to adhere to by different implementations of an interface. Of course, we are wholeheartedly for the "easier" part. Thus, we want the communication between objects to be as stable as possible (see next section on the explanation of "as possible").</p>

<h4>Communication patterns stability</h4>

<p>Remember the change Johnny and Benjamin had to make in order to add another kind of employees to the application? In order to do that, they had to change existing interfaces and add new ones. This was a lot of work. We don't want to do this much work every time we make a change. The reason they had to do so much changes was that the protocol between the objects they were dealing with was unstable. And they were unstable because they were:</p>

<ol>
  <li>complicated rather than simple</li>
  <li>concrete rather than abstract</li>
  <li>large rather than small</li>
</ol>

<p>Driven by why the stability of the protocols is bad, we can come up with some qualities that make protocols stable:</p>

<ol>
  <li>protocols should be simple</li>
  <li>protocols should be abstract</li>
  <li>protocols should be logical</li>
  <li>protocols should be small</li>
</ol>

<p>And there are some heuristics that let us get closer to these qualities:</p>

<h4>Short interactions</h4>

<p>TODO may be many small interfaces we interact with. Constructor bloat</p>

<h4>Method calls crafted from the perspective of senders</h4>

<p>The protocols are simpler if they are designed from the perspective of the object that sends the signal, not the one that receives it. In other words, methods should be adjusted to exactly meet the needs of the senders.</p>

<p>As an example, let us look at a code for logging in:</p>

<pre>accessGuard.SetLogin(login);
accessGuard.SetPassword(password);
accessGuard.Login();</pre>

<p>In this little snippet, the sender must invoke three methods, even though there is no real need to divide the logic into three steps - they are all executed in the same place anyway. The maker of this class might have thought that this division makes the class more "general purpose", but it seems this is a "premature optimization" that only makes it harder for the sender to work with the <code>accessGuard</code> object. Thus, the protocol that is simpler from the perspective of sender would be:</p>

<pre>accessGuard.LoginWith(login, password);</pre>

<p>Another lesson from the above example is: setters rarely reflect senders' intention. Most often, they reflect the structure of the recipient. <code>myObject.SetX(x)</code> call suggests that <code>myObject</code> holds value X. But it is rarely the intention of objects that use <code>myObject</code> to store information in it (unless it is a data structure, e.g. a collection or a data persistence abstraction), rather, they want <code>myObject</code> to do something for them and the setter is just an intermediate step required by <code>myObject</code>. In such cases, setters should be either avoided or changed to something that reflects the intention better. For example, when dealing with observer pattern, we don't want to say: <code>object.SetObserver(screen)</code>, but rather <code>object.RegisterObserver(screen)</code>.</p>

<p>Another thing is naming. The names of the methods (and interfaces for that matter) should be crafted from the perspective of the sender as well. In other words, the name of the method should not tell <emph>how</emph> thing is done (unless that matters from the perspective of the sender), but rather what is the intention of the sender that invokes the method. I love the example that Scott Bain gives in his <emph>Emergent Design</emph> book: if I told you "give me your driving license number", you might've reacted differently based on whether the driving license is in your pocket, or your wallet, or your bag, or in your home and you have to call someone to give it to you. The point is: I, as a sender of this "give me your driving license number" message, do not care how you get it. I say <code>RetrieveDrivingLicenseNumber()</code>, not <code>OpenYourWalletAndReadTheNumber()</code>. This is important, because if the name represents the sender's intention, the method will not have to be renamed when new classes are created that fulfill this intention in a different way.</p>.

<!--
<p>The last thing is:</p>
<p>plus no 15 variants of the same method, unless each is needed by a different client</p>
<p>Setters should be avoided</p>
-->

<h4>Interactions should reflect the domain</h4>

<p>Sometimes at work, I am asked to conduct a design workshop. The example I often give to my colleagues is to design a system for order reservation. The thing that struck me the first few times I did this workshop was that nearly none of the attendees had an <code>Order</code> abstraction with <code>Reserve()</code> method on it. Most of the attendees assume that <code>Order</code> is a data structure and handle reservation by adding it to a "collection of reserved items":</p>

<pre>reservedOrders.Add(order)</pre>

<p>While this achieves the functionality they need to implement, it does not reflect the domain. Thus, it can be affected by changes other than domain changes. Thus, the interactions between objects become less stable.</p>

<p>On the other hand, let's assume that we have a code for handling alarms. On each alarm, all gates are closed, sirens are turned on and message is sent to special forces with highest priority. Any error in this procedure leads to shutting down power in the building. If this workflow is coded like this:</p>

<pre>try
{
  gates.CloseAll();
  sirens.TurnOn();
  specialForces.NotifyWith(Priority.High);
} 
catch(SecurityFailure failure)
{
  powerSystem.TurnOffBecauseOf(failure);
}</pre>

<p>Then the risk of this code changing for other reasons than the change of how domain works (e.g. we do not close the gates anymore but activate laser guns instead) is small. Thus, interactions that use abstractions and methods that directly express domain rules are more stable.</p>

<p>Object responsibilities change less often than their data and if they do, they affect the design in a more predictable way. If a design reflects the domain, a change in design that is a result of domain rules change is easier to predict. This contributes to maintainability and stability of the interactions and the design as a whole.</p>


<h4>Objects should be told what to do, instead of asked for information</h4>

<p>This is probably one of the most important guidelines, known under the name of Tell Don't Ask. When an object is asked to perform a task instead of asked questions, we have a change of switching the implementation of this task with another one.</p>

<p>So remember the payroll system that Johnny and Benjamin were working on? As long as their code for giving raise looked like this:</p>

<pre>if(employee.GetSalary() &lt; payGrade.Maximum)
{
 var newSalary 
  = employee.GetSalary() 
  + employee.GetSalary() 
  * 0.1;
  employee.SetSalary(newSalary);
}
</pre>

<p>They were unable to compose this code with another employees that had different raise rules applied to them, including volountary employees that would not have raises, but may have bonuses.</p>

<p>Again, quoting Scott Bain, "what you hide, you can change". Thus, telling an object what to do requires less knowledge than asking for data and information. Going back to the driver license example: I may ask another person for a driving license number to actually make sure they have the license and that it is valid (by checking the number somewhere). I may also ask another person to provide me with the directions to the place I want the first person to drive. But isn't it easier to just tell "buy me some bread and butter"? Then, whoever I ask, has the freedom to either drive, or walk (if they know a good store nearby) or ask yet another person to do it instead. I don't care as long as tomorrow morning, I find the bread and butter in my fridge.</p>

<p>This guideline should be trated very, very seriously and applied in almost an extreme way. There are few places where it does not apply and we'll get back to them later.</p>

<h4>Getters should be removed</h4>

<p>The above stated guideline of "Tell Don't Ask" has a practical implication of getting rid of (almost) all the getters.</p>

<p>For me, this was very extreme at first, but in a short time I learned that this is actually how I am supposed to write object-oriented code. You see, I started learning programming using structural languages such as C, where a program was divided into procedures or functions and data structures. Then I moved on to object-oriented languages that allowed far better abstraction, but my style of coding didn't really change much. I would still have procedures and functions, but now more abstract (divided into objects) and data structures, but now more abstract (i.e. objects with setters, getters and some other query methods).</p>

<p>But what alternatives do we have? Let's say that we have a piece of software that handles user sessions (e.g. modeled using a <code>Session</code> class). We want to be able to display the sessions on the GUI, send the sessions through the network and persist them. How can we do this without getters? Should we put all the code for displaying, sending and storing inside the <code>Session</code> class? If we did that, we would couple a core domain concept (session) to a nasty set of third-party libraries (e.g. a particular GUI library), which would force us to tinker in core domain rules every time some GUI displaying concept changed. Also, if we did that, the <code>Session</code> would be hard to reuse, because every place we would want to reuse the class, we would need to take all these heavy libraries it depends on with us. So, our (not so good, as we will see) remedy may be to introduce getters for the information pieces stored inside a session:</p>

<pre>public class Session
{
  string GetOwner();
  string GetTarget();
  DateTime GetExpiryTime();
}</pre>

<p>So yeah, in a way, we have achieved context independence, because we can now pull all the data e.g. in a GUI code and display the data and the <code>Session</code> does not know anything about it:</p>

<pre>// inside GUI code
foreach(var session in sessions)
{
  ownerField.Text = session.GetOwner();
  targetField.Text = session.GetTarget();
  expiryTimeField.Text = session.GetExpiryTime();
}</pre>

<p>It seems we solved the problem, by pulling data to a place that has the context, i.e. knows what to do with this data. Are we happy? We may be unless we look at how the other parts look like - the sending one:</p>

<pre>//part of sending logic
foreach(var session in sessions)
{
  message.Owner = session.GetOwner();
  message.Target = session.GetTarget();
  message.ExpiryTime = session.GetExpiryTime();
}</pre>

<p>and the storing one:</p>

<pre>//part of storing logic
foreach(var session in sessions)
{
  dataRecord.Owner = session.GetOwner();
  dataRecord.Target = session.GetTarget();
  dataRecord.ExpiryTime = session.GetExpiryTime();
}</pre>

<p>See anything disturbing here? If no, then imagine what happens when we add another piece of information to the <code>Session</code>, say, priority. We now have three places to update and we have to remember to update all of them every time. This is called <emph>"redundancy"</emph> or <emph>"asking for trouble"</emph>. Also, composability of this class is pretty bad, because it will change a lot just because data in a session changes.</p>

<p>The reason for this is that we made the <code>Session</code> class effectively as a data structure. It does not implement any domain-related behaviors, just exposes data. There are two implications of this:</p>

<ol>
<li>this forces all users of this class to define session-related behaviors on behalf of the <code>Session</code>, meaning these behaviors are scattered all over the place. If one is to make change to the session, they must find all related behaviors and correct them.</li>
<li>as a set of object behaviors is generally more stable than its internal data (e.g. a session might have more than one target one day, but we will always be starting and stopping sessions), this leads to brittle interfaces and protocols - certainly the opposite of what we are striving for.</li>
</p>

<p>As we see, the solution is pretty bad. But we seem to be out of solutions. Shouldn't we just accept that there will be problems with this implementation and move on? Thankfully, no. So far, we have found the following options to be troublesome:</p>

<ol>
  <li>The <code>Session</code> class containing the display, store and send logic, i.e. all the context needed - too much coupling to heavy dependencies</li>
  <li>The <code>Session</code> class to expose its data so that we may pull it where we have enough context to know how to use it - communication is too brittle and redundancy creeps in (by the way, this design will also be bad for multithreading, but that's something for another time)</li>
</ol>

<p>Thankfully, we have a third alternative, which is better than the two we already mentioned. We can just <strong>pass</strong> the context <strong>into</strong> the <code>Session</code> class. "Isn't this just another way to do what we outlined in point 1? If we pass the context in, isn't <code>Session</code> still coupled to this context?", you may ask. The answer is: no, because we can make <code>Session</code> class depend on interfaces only to make it context-independent.</p>

<p>Let's see how this plays out in practice. First let's remove those ugly getters from the <code>Session</code> and introduce new method called <code>Dump()</code> that will take the <code>Destination</code> interface as parameter and pass all fields into this destination:</code>

<pre>public class Session
{
  public void Dump(Destination destination)
  {
    destination.AcceptOwner(this.owner);
    destination.AcceptTarget(this.owner);
    destination.AcceptExpiryTime(this.owner);
  }
}</pre>

<p>TODO write the rest!!</p>

<h4>Returning values should be extremely minimized</h4>

<p>Law of Demeter. Coupling to details of return values.</p>

<p>Size of protocols. Even interface with a single method can return a lot of values. Example: different reports produced.</p>

<h4>Context independence</h4>

<p>TODO</p>

<h4>Instead of pulling the data where context is, pass the context where the data is</h4>

<p>If you are like me, you probably learned programming starting from procedural languages.</p>

<p>this may sound like something non obvious</p>

<ol>
  <li>data - the information</li>
  <li>context - what we want to do with information</li>
</ol>

<p>e.g. for employees:</p>

<ol>
  <li>data - employee name surname etc.</li>
  <li>context - we want to print it on the screen</li>
</ol>

<p>TODO example: with employees loop getters refactoring</p>

<p>May be more coupling, but the coupling is very light - just an abstract interface, especially if we were following the rest guidelines. On the other hand, better information hiding and decoupling users from details.</p>

<h4>Protocols should rely on abstractions</h4>

<p>e.g. Id abstraction can be either in or string or a combination of those. The protocol stays stable regardless of these changes</p>

<p>Plural is also an abstraction</p>


<p>--------------------------------</p>



<p>Todo interfaces checked by compiler, protocols not</p>

<h3>multiple interfaces multiple roles</h3>

<p>interfejsy zostaly omowione ale sa jeszcze protokoly</p>
<p>Protocols must be published! They are not private internal details</p>
<h3>Tell Don't Ask</h3>
<h3>Level of abstraction of protocols</h3>


<p>weaker = harder to implement another implementation</p>

<p>stad wynika ze lepiej uzywac interfejsow niz klas</p>

<p>TOOODOOO</p>

<ol>
  <li>Composition through constructor - a reference is passed by constructor</li>
  <li>Composition through factory</li>
  <li>Composition through setter</li>
  <li>Composition through passed in a method parameter</li>
</ol>

<h2>Why did I leave out inline creation and singletons? context independence!</h2>

        <ol>
<li>composability - learned from previous chapters</li>
<li>what does it mean to compose - obtain reference. Plug objects together - show UML version of composition first, then the version with "plugs".</li>
<li>composability long term (through constructor or setter) or short term (through parameter)?</li>
<li>composability - strong or weak a) class vs interface, b)(continuum  -public field, getter, method that does something)</li>
<li>In order to compose - Protocols vs interfaces</li>
<li>Abstract protocols are better</li>
<li>web of composable objects - like a real web - metaphor (when?)</li>
<li>Tell Don't Ask (when?)</li>
<li>Why not events? Roles!!!</li>
<li>discover interfaces - from inside or outside?</li>
<li>need driven development</li>

				</ol>

    </body>
</html>
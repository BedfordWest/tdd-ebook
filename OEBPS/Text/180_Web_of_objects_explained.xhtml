<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Web of objects explained</title>
        <link href="../Styles/Global.css" rel="stylesheet" type="text/css"/>
    </head>
    <body>

<h1>The need for mock objects</h1>

<p>We experienced mock objects in the chapter about tools, although at that point, I gave you an oversimplified and deceiving explanation of what a mock object is, promising that I will make up for it later. Now is the time.</p>

<p>Mock objects were made with specific goal in mind. In my mind, without understanding the real goal, you will probably misunderstand the means to the goal.</p>

<p>In this chapter, we will explore the qualities of object oriented design which make mock objects a viable tool.</p>

<h1>Composability... again!</h1>

<p>In the two previous chapters, we followed Johnny and Benjamin in discovering the benefits of and prerequisites for composability of objects. Actually, composability is number one quality of the design we're after. After reading Johhny and Benjamin's story, you might have some questions regarding composability. Hopefully, they are among these:</p>

<h2>Why do we need composability?</h2>

<p>it might seem stupid to ask this question here - if you managed to stay with me this far, then you're probably motivated enough not to need a justification? Well, anyway, it's still worth discussing it a little.</p>

<p>Back in the days of procedural programming, if a part of code needed to behave differently, it was usually achieved using an 'if' statement. For example, if we had few kinds of messages in our application, the following piece of code could usually be found inside:</p>

<pre>if(message-&gt;kind == MESSAGE_A)
{
  preprocessMessageA((MessageA*)message);
}
else if(message-&gt;kind == MESSAGE_B)
{
  preprocessMessageB((MessageB*)message);
}
else if(message-&gt;kind == MESSAGE_C)
{
  preprocessMessageB((MessageC*)message);
}</pre>

<p>And in another place, if we wanted to do another thing differently based on the message type, the choice of the message type would be duplicated, but with different set of actions to perform:</p>

<pre>if(message-&gt;kind == MESSAGE_A)
{
  storeMessageA((MessageA*)message);
}
else if(message-&gt;kind == MESSAGE_B)
{
  storeMessageB((MessageB*)message);
}
else if(message-&gt;kind == MESSAGE_C)
{
  storeMessageB((MessageC*)message);
}</pre>

<p> Procedural programming languages had some answers to those concerns, but they were mostly awkward. Object oriented programming, along with polymorphism, has brought a possibility to more easily change behavior. Instead of repeating an 'if-else' chain every time it was necessary to differentiate, a programmer can now make the differentiation once and store it inside an object:</p>

<pre>Message message = null;

if(kindOfMessage == MESSAGE_A)
{
  //polymorphic assignment
  message = new MessageA();
}
else if(kindOfMessage == MESSAGE_B)
{
  //polymorphic assignment
  message = new MessageB();
}
else if(kindOfMessage == MESSAGE_C)
{
  //polymorphic assignment
  message = new MessageC();
}</pre>

<p>Of course, this works only when we are able to come up with a common way of communicating with all these objects, i.e. a common interface. Then, the preprocessing code can just look like this:</p>

<pre>message.Preprocess();</pre>

<p>and storing code can look like this:</p>

<pre>message.Store();</pre>

<p>In those two pieces of code, we do not need to take into account the difference between different messages anymore, because the difference is already encoded in the real type of the object and polymorphism allows using an instance of such concrete type without knowing the concrete type.</p>

<p>This allows coding classes in such a way that can communicate with other objects without any awareness of the real types of these objects - only by knowing a common supertype. If we are able to do that, we can add new implementations of this supertype and make our objects work with these new implementations without having to change these objects. There is one condition, however - the creation of the objects that our class talks to must be moved out of our class. That's because to use a <code>new</code> operator, a piece of code has to know the exact type of the object it is creating, which is exactly what we are trying to avoid.</p>

<p>Moving creation of objects away from the classes that use those objects brings up an interesting problem - if an object does not create its own dependencies, then who does it? A solution is to make a special place in the code that assembles a system from loosely coupled objects.</p>

<p>TODO add example</p>

<p>If we are able to separate object creation from usage, it gives us an important advantage - in order to make our existing objects work with new implementations of abstractions they depend upon, all we need to do (aside of coding the new implementations the right way - more on this later) is to modify the code that is putting the system together (i.e. <strong>composing objects into a system</strong>) and all other objects may remain untouched. This is important in evolutionary, incremental design, where we want to evolve some pieces of code with as little as possible other pieces of code having to realize that the evolution takes place.</p>

<h2>So, again, what does it mean to compose objects?</h2>

<p>Basically it means that an object has obtained a reference to another object and is invoking methods on it. By being composed together, two objects form a small system that can be expanded with more objects. Thus, a bigger object oriented system forms something that reminds of a web:</p>

<img alt="Obraz" src="../Images/WebOfObjects.svg" />

<p>If we take the metaphor a little bit further, we can note some similarities to e.g. a TCP network:</p>

<ol>
  <li>An object can send <strong>messages</strong> to other objects (i.e. call methods on them) using <strong>interfaces</strong>. Each message has a <strong>sender</strong> and a <strong>recipient</strong>.</li>
  <li>In order to do that, an object has to acquire an <strong>address</strong> of another object, which, in object oriented world, we call a reference.</li>
  <li>A communication between objects has to obey certain <strong>protocol</strong> (more on this later).</li>
</ol>

<p>Let us try this out on an example. Let's say that we have an alarm that, when triggered, makes all lifts go to bottom floor, opens them and then disables them.</p>

<p>First, an alarm has to acquire "addresses" of the lifts. We can pass them e.g. through a constructor:</p>

<pre>public class Alarm
{
  //references are stored
  private readonly IEnumerable&ltlLift&gt; _lifts;

  public Alarm(IEnumerable&ltlLift&gt; lifts)
  {
    _lifts = lifts;
  }
}</pre>

<p>Then, the alarm can send three messages: <code>GoToBottomFloor()</code>, <code>OpenDoor()</code>, and <code>DisablePower()</code> to all the lifts through the <code>Lift</code> interface:</p>

<pre>public void Trigger()
{
  foreach(var lift in _lifts)
  {
    lift.GoToBottomFloor();
    lift.OpenDoor();
    lift.DisablePower();
  }
}</pre>

<p>In this communication, <code>Alarm</code> is a sender - it knows what it is sending, but does not know how exactly the message will be handled. This is left to <code>Lift</code> objects that are recipients - they do not know who they got the message from, but they know how to react, based on what the message is and what's its content (i.e. method arguments).</p>

<img alt="Obraz" src="../Images/SenderRecipientMessage.svg" />

<p>Also, it has been decided that whenever any malfunction happens when executing the alarm emergency procedure, a <code>Lift</code> object is going to report this by throwing an exception called <code>LiftUnoperationalException</code>. The <code>Alarm</code>, thus, needs to know this and be able to handle this, e.g.</p>

<pre>public void Trigger()
{
  foreach(var lift in _lifts)
  {
    try
    {
      lift.GoToBottomFloor();
      lift.OpenDoor();
      lift.DisablePower();
    }
    catch(LiftUnoperationalException e)
    {
      report.ThatCannotSecure(lift);
    }
  }
}</pre>

<p>In other words, there is a protocol between <code>Alarm</code> and <code>Lift</code> that must be adhered to. <code>Lift</code> is expected to report issues in a certain way and <code>Alarm</code> is expected to be able to handle the issues.</p>


<p>Each of the objects in the web can receive messages and most of them send messages to other objects. Throughout this chapter, I will refer to an object sending a message as sender and an object receiving a message as recipient.</p>

<p>As I said, there is a special place in the code where the web is assembled from context-independent objects. This place is sometimes called "composition root".</p>

<p>TODO</p>

<h2>How are objects composed?</h2>

<p>There are various ways to compose two objects depending on how a reference to an object is obtained and how long the composition lasts.</p>

<h3>Constructor</h3>

<p>Two objects can be composed by passing one into the constructor of another:</p>

<pre>sender = new Sender(recipient);</pre>

<p>Here, a sender is composed with a recipient and stores a reference to the recipient in a private field, like this:</p>

<pre>public Sender(Recipient recipient)
{
  this._recipient = recipient;
}</pre>

<p>The code that performs this composition is most often in a totally different place than the client code calling methods on the <code>Sender</code>. Thus, this client code does not need to know that such a composition took place. The existence of <code>Recipient</code> is hidden from it. This basically means that in the implementation of the following call:</p>

<pre>sender.DoSomething()</pre>

<p><code>Sender</code> may send message to <code>Recipient</code> internally, but the code invoking the <code>DoSomething()</code> method is completely unaware of that.</p>

<p>Constructor is a great way to compose sender with a recipient permanently. In order to be able to do this, a <code>Recipient</code> must, of course, exist before a <code>Sender</code> does. Another less obvious requirement for this composition is that <code>Recipient</code> must be usable at least as long as <code>Sender</code> is usable. In other words, the following is nonsense:</p>

<pre>sender = new Sender(recipient);
recipient.Dispose(); //but sender is unaware and may still use recipient:
sender.DoSomething();</pre>

<h3>Method parameter</h3>

<p>Another common way of composing objects together is passing one object as a parameter of another object's method call:</p>

<pre>sender.DoSomethingTo(recipient);</pre>

<p>Here, the objects are most often composed temporarily, just for this single method.</p>

<p>This is a great way to compose objects when we want to use the same sender with different recipients at different times (most often from different parts of the code).</p>

<h3>Factories</h3>

<p>This method of composing objects uses another intermediary object - a factory. In other words, the sender is first composed with a factory via constructor:</p>

<pre>sender = new Sender(factory);</pre>

<p>and then the factory is used to deliver other objects:</p>

<pre>public class Sender
{
  //...

  public DoSomething() 
  {
    recipient = _factory.CreateRecipient();
    recipient.DoSomethingElse();
  }
}</pre>

<p>This kind of composition is beneficial when a different recipient is needed each time <code>DoSomething()</code> is called, but at the same time, contrary to passing recipient as a method parameter, the client should not (or cannot) be responsible for supplying a recipient.</p>

<h3>Register methods</h3>

<p>e.g. setters, register(), add() etc.</p>

<h2>Weaker and better composability</h2>

<p>Some classes are harder to compose with other classes, others are easier. There are numerous factors influencing this:</p>

<h3>Classes vs interfaces</h3>

<p>As we said, an object is composed with another object by obtaining a reference to something. Also, we said that we want the flexibility of plugging in objects of different classes at different times. This is, of course, done using polymorphism, as Johnny and Benjamin did when cleaning up the payroll system. So, what should be the base for polymorphism? Is a class sufficient, or do we rather want to use an interface? In other words, when we plug in an object as a message receipient:</p>

<pre>public Sender(Recipient recipient)
{
  this._recipient = recipient;
}</pre>

<p>Should the Recipient be a class or an interface?</p>

<p>If we assume that Recipient is a class, we can get the composability we want by deriving another class from it and overriding methods. However, using a class as a base for composability has the following weaknesses:</p>

<ol>
  <li>The superclass may have real dependencies. For example, if <code>Recipient</code> class depends on WCF stack, then everywhere we take our Sender to compose it with different recipients, we must also take our <code>Recipient</code> and its WCF dependency.</li>
  <li>We force each recipient class we want to compose our sender with to invoke a constructor from superclass, which, depending on the complexity of the superclass, may be smaller or bigger trouble.</li>
  <li>In languages like C#, when only single inheritance exists all the classes that want to be composed with our <code>Sender</code>, we waste the only inheritance slot, further constraining the inheriting classes.</li>
  <li>We must take care to make all methods of <code>Recipient</code> superclass virtual to enable overriding by subclasses. otherwise, we won't have full composability.</li>
</ol>

<p>As you see, there are some difficulties using classes as "slots for composability", even if composition is possible this way. Thus, interfaces are far better, just because they are easier to use for this purpose.</p>

<p>It is decided then, If a sender wants to be composable with recipient, it has to accept a reference to recipient in form of interface reference. We can say that, by being light-weight and implementationless, <strong>interfaces can be treated as "slots" for plugging in different objects</strong>.</p>

<p>In fact, when we look at how interfaces are depicted on UML class diagrams, it seems that the "interface as slot for composition" notion is not unusual:</p>

<p>TODO insert a picture showing one notation of interfaces in UML.</p>

<p>It is just that we try to take the notion of composability to its fullest, as not only a first-class citizen, but as THE most important aspect of our design approach.</p>

<h3>Events vs interfaces</h3>

<p>TODO TODO TODO TODO</p>

<h3>Small interfaces</h3>

<p>Ok, so we said that he interfaces are "the way to go" for reaching the strong composability we're striving for. Is it enough just to "have interfaces"? No, actually, it's not.</p>

<p>One of the other things we need to consider is the size of interfaces. Let's state one thing that is obvious in regard to this:</p>

<p><strong>All other things equal, smaller interfaces are easier to implement that bigger interfaces.</strong></p>

<p>The obvious conclusion from this is that if we want to have really strong composability, our "slots", i.e. interfaces, have to be as small as possible. Of course, we cannot achieve this by removing methods that are needed from the interfaces, e.g. when someone is using an interface implementation like this:</p>

<pre>recipient.SomethingHappened();
recipient.SomethingElseHappened();</pre>

<p>It is impossible to just remove either method from the interface, or the client will stop compiling.</p>

<p>So, what do we do then? We try to separate different interfaces per client. After all, a class can implement more than one interface, like this:</p>

<pre>public class ImplementingObject 
: InterfaceForClient1, 
  InterfaceForClient2,
  InterfaceForClient3
{ ... }</pre>

<p>This notion of using a separate interface per client and not one bigger interface for different clients is known as the Interface Segregation Principle.</p>

<h4>A simple example: separation of reading from writing</h4>

<p>For example, we may have a class representing organizational structure in our application. On one hand, the application is notified on any changes that are made from administration interface. On the other hand, it supports client-side operations for ordinary users, e.g. listing all users. The interface for this organizational structure class may look like this:</p>

<pre>public interface 
OrganizationStructure
{
  //administrative part:
  void Make(Change change);
  
  //client-side part:
  void ListAllEmployees(
    EmployeeDestination destination);
}</pre>

<p>but, most certainly, the two sets of methods will be used by different code - one related to handling administrative requests, another related to handling ordinary user requests. Thus, we can use this knowledge to separate the interface into two:</li>

<pre>public interface
OrganizationalStructureAdminCommands
{
  void Make(Change change);
}

public interface
OrganizationalStructureClientCommands
{
  void ListAllEmployees(
    EmployeeDestination destination);
}</pre>

<p>And a real class can implement both of them:</p>

<pre>public class InMemoryOrganizationalStructure
: OrganizationalStructureAdminCommands,
  OrganizationalStructureClientCommands
{
  //...
}</pre>
<p>Sure, there are more interfaces, but that doesn't bother us much, because in return, each interface is easier to implement. In other words, it is easier to make new implementations we can compose users of those interfaces with. This means that composability is enhanced, which is what we want the most. After all, nobody said there will always be a single class implementing both interfaces. One day, we maye get a requirement that all writes to the organizational structure have to be traced. In such case, All we have to do is to create new class implementing <code>OrganizationalStructureAdminCommands</code> which will wrap the original method with a notification to a change observer (that can be either the trace that is required or anything else we like):</p>

<pre>public class NotifyingAdminComands : OrganizationalStructureAdminCommands
{
  public NotifyingCommands(
    OrganizationalStructureAdminCommands wrapped,
    ChangeObserver observer)
  {
    _wrapped = wrapped;
    _observer = observer;
  }

  void Make(Change change)
  { 
    _wrapped.Make(change);
    _observer.NotifyAbout(change);
  }
}</pre>

<p>If we did not separate interfaces for admin and client access, in our <code>NotifyingAdminComands</code> class, we would have to implement the <code>ListAllEmployees</code> method and make it delegate to the original wrapped instance. Splitting the interface into two smaller ones spared us this trouble.</p>

<h4>Interfaces should rely on abstractions</h4>

<p>TODO</p>

<h3>Protocols</h3>

<p>So, we said that objects are connected (composed) together and communicate through interfaces, just as in IP network. There is another similarity though, that's as important. It's protocols.</p>

<h4>Protocols exist</h4>

<p>I do not want to introduce any scientific definition, so let's just establish an understanding that protocols are sets of rules about how objects communicate with each other. Really? Are there any rules? Is it not enough the the objects can be composed together through interfaces? Well, not, it's not enough and let me give you a quick example.</p>

<p>Let us imagine a class <code>Sender</code> that uses <code>Recipient</code> like this:</p>

<pre>if(recipient.ExtractStatusCodeFrom(response) == -1)
{
  observer.NotifyErrorOccured();
}</pre>

<p>Stupid as it is, the example shows one important thing. Whoever the recipient is, it is expected to report error as -1. Otherwise, the <code>Sender</code> will not be able to react to the error situation appropriately. Similarly, the recipient must not report "no error" situation as -1, because if it does, this will be mistakenly recognized as error by <code>Sender</code>. So for example this implementation of <code>Recipient</code>, although implementing the required interface, is wrong from the point of view of <code>Sender</code>:</p>

<pre>public class WrongRecipient : Recipient
{
  public int ExtractStatusFrom(Response response)
  {
    if( /* success */ )
    {
      return -1; // but other than -1 should be used!
    }
    else
    {
      return 1; // -1 should be used!
    }
  }
}</pre>

<p>So as you see, we cannot just write anything in a class implementing an interface, because of protocol that imposes certain contract on both the sender and recipient. This contract may not only be about return values, it can also be on types of exceptions thrown, or the order of method calls. For example, anybody using some kind of connection object would imagine the following way of using the connection:</p>

<pre>connection.Open();
connection.Send(data);
connection.Close();</pre>

<p>Again, if we were to implement a connection that behaves like this:</p>

<pre>public class WrongConnection : Connection
{
  public void Open()
  {
    //...close connection
  }

  public void Close()
  {
    //...open connection
  }
}</pre>

<p>it would compile just fine, but fail badly when executed.</p>

<p>So, again, there are certain rules that restrict the way two objects can communicate. Both sender and recipient of a message must adhere to the rules, or the they will not be able to work together.</p>

<p>The good news is that WE are the ones who design these protocols, along with the interfaces, so we can design them to be harder or easier to adhere to by different implementations of an interface. Of course, we are wholeheartedly for the "easier" part. Thus, we want the communication between objects to be as stable as possible (see next section on the explanation of "as possible").</p>

<h4>Communication patterns stability</h4>

<p>Remember the change Johnny and Benjamin had to make in order to add another kind of employees to the application? In order to do that, they had to change existing interfaces and add new ones. This was a lot of work. We don't want to do this much work every time we make a change. The reason they had to do so much changes was that the protocol between the objects they were dealing with was unstable. And they were unstable because they were:</p>

<ol>
  <li>complicated rather than simple</li>
  <li>concrete rather than abstract</li>
  <li>large rather than small</li>
</ol>

<p>Driven by why the stability of the protocols is bad, we can come up with some qualities that make protocols stable:</p>

<ol>
  <li>protocols should be simple</li>
  <li>protocols should be abstract</li>
  <li>protocols should be logical</li>
  <li>protocols should be small</li>
</ol>

<p>And there are some heuristics that let us get closer to these qualities:</p>

<h4>Short interactions</h4>

<p>TODO may be many small interfaces we interact with. Constructor bloat</p>

<h4>Method calls crafted from the perspective of senders</h4>

<p>The protocols are simpler if they are designed from the perspective of the object that sends the signal, not the one that receives it. In other words, methods should be adjusted to exactly meet the needs of the senders.</p>

<p>As an example, let us look at a code for logging in:</p>

<pre>accessGuard.SetLogin(login);
accessGuard.SetPassword(password);
accessGuard.Login();</pre>

<p>In this little snippet, the sender must invoke three methods, even though there is no real need to divide the logic into three steps - they are all executed in the same place anyway. The maker of this class might have thought that this division makes the class more "general purpose", but it seems this is a "premature optimization" that only makes it harder for the sender to work with the <code>accessGuard</code> object. Thus, the protocol that is simpler from the perspective of sender would be:</p>

<pre>accessGuard.LoginWith(login, password);</pre>

<p>Another lesson from the above example is: setters rarely reflect senders' intention. Most often, they reflect the structure of the recipient. <code>myObject.SetX(x)</code> call suggests that <code>myObject</code> holds value X. But it is rarely the intention of objects that use <code>myObject</code> to store information in it (unless it is a data structure, e.g. a collection or a data persistence abstraction), rather, they want <code>myObject</code> to do something for them and the setter is just an intermediate step required by <code>myObject</code>. In such cases, setters should be either avoided or changed to something that reflects the intention better. For example, when dealing with observer pattern, we don't want to say: <code>object.SetObserver(screen)</code>, but rather <code>object.RegisterObserver(screen)</code>.</p>

<p>Another thing is naming. The names of the methods (and interfaces for that matter) should be crafted from the perspective of the sender as well. In other words, the name of the method should not tell <emph>how</emph> thing is done (unless that matters from the perspective of the sender), but rather what is the intention of the sender that invokes the method. I love the example that Scott Bain gives in his <emph>Emergent Design</emph> book: if I told you "give me your driving license number", you might've reacted differently based on whether the driving license is in your pocket, or your wallet, or your bag, or in your home and you have to call someone to give it to you. The point is: I, as a sender of this "give me your driving license number" message, do not care how you get it. I say <code>RetrieveDrivingLicenseNumber()</code>, not <code>OpenYourWalletAndReadTheNumber()</code>. This is important, because if the name represents the sender's intention, the method will not have to be renamed when new classes are created that fulfill this intention in a different way.</p>.

<!--
<p>The last thing is:</p>
<p>plus no 15 variants of the same method, unless each is needed by a different client</p>
<p>Setters should be avoided</p>
-->

<h4>Interactions should reflect the domain</h4>

<p>Sometimes at work, I am asked to conduct a design workshop. The example I often give to my colleagues is to design a system for order reservation. The thing that struck me the first few times I did this workshop was that nearly none of the attendees had an <code>Order</code> abstraction with <code>Reserve()</code> method on it. Most of the attendees assume that <code>Order</code> is a data structure and handle reservation by adding it to a "collection of reserved items":</p>

<pre>reservedOrders.Add(order)</pre>

<p>While this achieves the functionality they need to implement, it does not reflect the domain. Thus, it can be affected by changes other than domain changes. Thus, the interactions between objects become less stable.</p>

<p>On the other hand, let's assume that we have a code for handling alarms. On each alarm, all gates are closed, sirens are turned on and message is sent to special forces with highest priority. Any error in this procedure leads to shutting down power in the building. If this workflow is coded like this:</p>

<pre>try
{
  gates.CloseAll();
  sirens.TurnOn();
  specialForces.NotifyWith(Priority.High);
} 
catch(SecurityFailure failure)
{
  powerSystem.TurnOffBecauseOf(failure);
}</pre>

<p>Then the risk of this code changing for other reasons than the change of how domain works (e.g. we do not close the gates anymore but activate laser guns instead) is small. Thus, interactions that use abstractions and methods that directly express domain rules are more stable.</p>

<p>Object responsibilities change less often than their data and if they do, they affect the design in a more predictable way. If a design reflects the domain, a change in design that is a result of domain rules change is easier to predict. This contributes to maintainability and stability of the interactions and the design as a whole.</p>

<h4>Objects should be told what to do, instead of asked for information</h4>

<p>This is probably one of the most important guidelines, known under the name of Tell Don't Ask. When an object is asked to perform a task instead of asked questions, we have a change of switching the implementation of this task with another one.</p>

<p>So remember the payroll system that Johnny and Benjamin were working on? As long as their code for giving raise looked like this:</p>

<pre>if(employee.GetSalary() &lt; payGrade.Maximum)
{
 var newSalary 
  = employee.GetSalary() 
  + employee.GetSalary() 
  * 0.1;
  employee.SetSalary(newSalary);
}
</pre>

<p>They were unable to compose this code with another employees that had different raise rules applied to them, including voluntary employees that would not have raises, but may have bonuses.</p>

<p>Again, quoting Scott Bain, "what you hide, you can change". Thus, telling an object what to do requires less knowledge than asking for data and information. Going back to the driver license example: I may ask another person for a driving license number to actually make sure they have the license and that it is valid (by checking the number somewhere). I may also ask another person to provide me with the directions to the place I want the first person to drive. But isn't it easier to just tell "buy me some bread and butter"? Then, whoever I ask, has the freedom to either drive, or walk (if they know a good store nearby) or ask yet another person to do it instead. I don't care as long as tomorrow morning, I find the bread and butter in my fridge.</p>

<p>This guideline should be trated very, very seriously and applied in almost an extreme way. There are few places where it does not apply and we'll get back to them later.</p>

<h4>Getters should be removed, return values should be avoided</h4>

<p>The above stated guideline of "Tell Don't Ask" has a practical implication of getting rid of (almost) all the getters.</p>

<p>For me, this was very extreme at first, but in a short time I learned that this is actually how I am supposed to write object-oriented code. You see, I started learning programming using structural languages such as C, where a program was divided into procedures or functions and data structures. Then I moved on to object-oriented languages that allowed far better abstraction, but my style of coding didn't really change much. I would still have procedures and functions, but now more abstract (divided into objects) and data structures, but now more abstract (i.e. objects with setters, getters and some other query methods).</p>

<p>But what alternatives do we have? Let's say that we have a piece of software that handles user sessions (e.g. modeled using a <code>Session</code> class). We want to be able to display the sessions on the GUI, send the sessions through the network and persist them. How can we do this without getters? Should we put all the code for displaying, sending and storing inside the <code>Session</code> class? If we did that, we would couple a core domain concept (session) to a nasty set of third-party libraries (e.g. a particular GUI library), which would force us to tinker in core domain rules every time some GUI displaying concept changed. Also, if we did that, the <code>Session</code> would be hard to reuse, because every place we would want to reuse the class, we would need to take all these heavy libraries it depends on with us. So, our (not so good, as we will see) remedy may be to introduce getters for the information pieces stored inside a session:</p>

<pre>public interface Session
{
  string GetOwner();
  string GetTarget();
  DateTime GetExpiryTime();
}</pre>

<p>So yeah, in a way, we have achieved context independence, because we can now pull all the data e.g. in a GUI code and display the data and the <code>Session</code> does not know anything about it:</p>

<pre>// inside GUI code
foreach(var session in sessions)
{
  var tableRow = TableRow.Create();
  tableRow["owner"] = session.GetOwner();
  tableRow["target"] = session.GetTarget();
  tableRow["expiryTime"] = session.GetExpiryTime();
  table.Add(tableRow);
}</pre>

<p>It seems we solved the problem, by pulling data to a place that has the context, i.e. knows what to do with this data. Are we happy? We may be unless we look at how the other parts look like - the sending one:</p>

<pre>//part of sending logic
foreach(var session in sessions)
{
  var message = Message.Blank();
  message.Owner = session.GetOwner();
  message.Target = session.GetTarget();
  message.ExpiryTime = session.GetExpiryTime();
  connection.Send(message);
}</pre>

<p>and the storing one:</p>

<pre>//part of storing logic
foreach(var session in sessions)
{
  var record = Record.Blank();
  dataRecord.Owner = session.GetOwner();
  dataRecord.Target = session.GetTarget();
  dataRecord.ExpiryTime = session.GetExpiryTime();
  database.Save(record);
}</pre>

<p>See anything disturbing here? If no, then imagine what happens when we add another piece of information to the <code>Session</code>, say, priority. We now have three places to update and we have to remember to update all of them every time. This is called <emph>"redundancy"</emph> or <emph>"asking for trouble"</emph>. Also, composability of this class is pretty bad, because it will change a lot just because data in a session changes.</p>

<p>The reason for this is that we made the <code>Session</code> class effectively as a data structure. It does not implement any domain-related behaviors, just exposes data. There are two implications of this:</p>

<ol>
<li>this forces all users of this class to define session-related behaviors on behalf of the <code>Session</code>, meaning these behaviors are scattered all over the place. If one is to make change to the session, they must find all related behaviors and correct them.</li>
<li>as a set of object behaviors is generally more stable than its internal data (e.g. a session might have more than one target one day, but we will always be starting and stopping sessions), this leads to brittle interfaces and protocols - certainly the opposite of what we are striving for.</li>
</p>

<p>As we see, the solution is pretty bad. But we seem to be out of solutions. Shouldn't we just accept that there will be problems with this implementation and move on? Thankfully, no. So far, we have found the following options to be troublesome:</p>

<ol>
  <li>The <code>Session</code> class containing the display, store and send logic, i.e. all the context needed - too much coupling to heavy dependencies</li>
  <li>The <code>Session</code> class to expose its data so that we may pull it where we have enough context to know how to use it - communication is too brittle and redundancy creeps in (by the way, this design will also be bad for multithreading, but that's something for another time)</li>
</ol>

<p>Thankfully, we have a third alternative, which is better than the two we already mentioned. We can just <strong>pass</strong> the context <strong>into</strong> the <code>Session</code> class. "Isn't this just another way to do what we outlined in point 1? If we pass the context in, isn't <code>Session</code> still coupled to this context?", you may ask. The answer is: no, because we can make <code>Session</code> class depend on interfaces only to make it context-independent.</p>

<p>Let's see how this plays out in practice. First let's remove those ugly getters from the <code>Session</code> and introduce new method called <code>Dump()</code> that will take the <code>Destination</code> interface as parameter:</p> 

<pre>public interface Session
{
  void DumpInto(Destination destination);
}</pre>

<p>Its implementation can pass all fields into this destination like so:</p>

<pre>public class TimedSession : Session
{
  //...

  public void DumpInto(Destination destination)
  {
    destination.AcceptOwner(this.owner);
    destination.AcceptTarget(this.target);
    destination.AcceptExpiryTime(this.expiryTime);
    destination.Done();
  }

  //...
}</pre>

<p>And the looping through sessions now looks like this:</p>

<pre>foreach(var session : sessions)
{
  var newDestination = destinationFactory.Create();
  session.DumpInto(newDestination);
}</pre>

<p>In this design, <code>Session</code> itself decides which parameters to pass - no one is asking for its data. This <code>Dump()</code> method is fairly general, so we can use it to implement all three mentioned behaviors (displaying, storing, sending), by creating adapters for each type of destination, e.g. for GUI, it might look like this:</p>

<pre>public class GuiDestination : Destination
{
  private TableRow _row;
  private Table _table;
  
  public GuiDestination(Table table, TableRow row)
  {
    _table = table;
    _row = row;
  }

  public void AcceptOwner(string owner)
  {
    _row["owner"] = owner;
  }

  public void AcceptTarget(string target)
  {
    _row["target"] = target;
  }

  public void AcceptExpiryTime(DateTime expiryTime)
  {
    _row["expiryTime"] = expiryTime;
  }

  public void Done()
  {
    _table.Add(_row);
  }

}</pre>

<p>Note that with the current design, adding new property to the <code>Session</code> that would need to be displayed, stored or sent, means adding new method to the <code>Destination</code> interface. All implementing classes must implement this new method, or they stop compiling, so there is no way to mistakenly forget about one of them.</p>

<p>Also, unnoticeably, the protocol got more stable. Previously, when we had the getters in the <code>Session</code> class:</p>

<pre>public class Session
{
  string GetOwner();
  string GetTarget();
  DateTime GetExpiryTime();
}</pre>

<p>the getters <strong>had to</strong> return <strong>something</strong>. So what if we didn't want to display, send and store expired timed sessions anymore? we would have to add another getter, called <code>IsExpired()</code> and checking it everywhere... you see where this is going. On the other hand, with the current design of the <code>Session</code> interface, we can e.g. introduce a feature where the expired sessions are not processed at all:</p>

<pre>public class TimedSession : Session
{
  //...

  public void DumpInto(Destination destination)
  {
    if(!IsExpired())
    {
      destination.AcceptOwner(this.owner);
      destination.AcceptTarget(this.target);
      destination.AcceptExpiryTime(this.expiryTime);
      destination.Done();
    }
  }

  //...
}</pre>

<p>and there is no need to change any other code to get this working.</p>

<p>Another added bonus of this situation that we do not have to return anything from methods is that we are free to apply proxy and decorator patterns more freely. For example, we may have hidden sessions, that are not displayed at all, but retain the rest of the session functionality. We may implement it as a proxy, that forwards all messages received to the original, wrapped <code>Session</code> object, while discarding the Dump calls:</p>

<pre>public class HiddenSession : Session
{
  private Session _innerSession;

  public HiddenSession(Session innerSession)
  {
    _innerSession = innerSession;
  }

  public void DoSomethig()
  {
    // forward the message:
    _innerSession.DoSomething();
  }

  //...

  public void DumpInto(Destination destination)
  {
    // discard the message - do nothing
  }

  //...
}</pre>

<p>The most important thing is that when we are not forced to return anything, we are more free to do as we like. Again, "Tell, don't ask".</p>

<p>The notion of passing context where the data is instead of pulling the data right into the context is often referred to as "context independence". Context independence is not only about passing context in methods - it applies to constructors the same way. Being context independent is one of the most important requirements for a class to be composable with other classes.</p>

<h3>Single Responsibility</h3>

<p>I already said that we want our system to be a web of composable objects. Also, I said that we want to be able to unplug a cluster of objects at any place and plug in something different. TODO</p>

             


<h4>Law of Demeter</h4>

<p>As we discovered, exposing return values makes the protocols more complex and should be avoided if possible. TODO do we need this at all?</p>

<p>Law of Demeter. Coupling to details of return values.</p>

<p>Size of protocols. Even interface with a single method can return a lot of values. Example: different reports produced.</p>

<h4>Context independence</h4>

<p>TODO</p>

<h4>Instead of pulling the data where context is, pass the context where the data is</h4>

<p>If you are like me, you probably learned programming starting from procedural languages.</p>

<p>this may sound like something non obvious</p>

<ol>
  <li>data - the information</li>
  <li>context - what we want to do with information</li>
</ol>

<p>e.g. for employees:</p>

<ol>
  <li>data - employee name surname etc.</li>
  <li>context - we want to print it on the screen</li>
</ol>

<p>TODO example: with employees loop getters refactoring</p>

<p>May be more coupling, but the coupling is very light - just an abstract interface, especially if we were following the rest guidelines. On the other hand, better information hiding and decoupling users from details.</p>

<h4>Protocols should rely on abstractions</h4>

<p>e.g. Id abstraction can be either in or string or a combination of those. The protocol stays stable regardless of these changes</p>

<p>Plural is also an abstraction</p>


<p>--------------------------------</p>

<h4>Interactions are not an implementation detail</h4>

<p>Todo interfaces checked by compiler, protocols not</p>

<h3>multiple interfaces multiple roles</h3>

<p>Protocols must be published! They are not private internal details</p>
<h3>Tell Don't Ask</h3>
<h3>Level of abstraction of protocols</h3>


<p>weaker = harder to implement another implementation</p>

<p>stad wynika ze lepiej uzywac interfejsow niz klas</p>

<p>TOOODOOO</p>

<ol>
  <li>Composition through constructor - a reference is passed by constructor</li>
  <li>Composition through factory</li>
  <li>Composition through setter</li>
  <li>Composition through passed in a method parameter</li>
</ol>

<h2>Why did I leave out inline creation and singletons? context independence!</h2>

        <ol>
<li>composability - learned from previous chapters</li>
<li>what does it mean to compose - obtain reference. Plug objects together - show UML version of composition first, then the version with "plugs".</li>
<li>composability long term (through constructor or setter) or short term (through parameter)?</li>
<li>composability - strong or weak a) class vs interface, b)(continuum  -public field, getter, method that does something)</li>
<li>In order to compose - Protocols vs interfaces</li>
<li>Abstract protocols are better</li>
<li>web of composable objects - like a real web - metaphor (when?)</li>
<li>Tell Don't Ask (when?)</li>
<li>Why not events? Roles!!!</li>
<li>discover interfaces - from inside or outside?</li>
<li>need driven development</li>

				</ol>

    </body>
</html>
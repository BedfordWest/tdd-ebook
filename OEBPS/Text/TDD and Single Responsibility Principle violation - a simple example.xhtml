<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>TDD and Single Responsibility Principle violation - a simple example</title>
</head>

<body>
  <p>As many have already stated, TDD encourages simple, elegant design. Today I'd like to show you a simple example on how you can smell <a href="http://www.objectmentor.com/resources/articles/srp.pdf">Single Responsibility Principle</a> violation from your specs (AKA unit tests).</p>

  <h3>A session storage</h3>

  <p>Imagine we're building a web server which allows different clients connect to it via HTTP requests. The server is so simple that it holds all its sessions for different clients in memory. One of the specs that led to implementing this in-memory session storage looks like this:</p>
  <pre class="brush: csharp">
[Test] public void
ShouldKillAllContainedSessionsWhenItIsKilled()
{
  var sessions = new Sessions();
  var session1 = Substitute.For&lt;Session&gt;();
  var session2 = Substitute.For&lt;Session&gt;();

  sessions.Add(session1);
  sessions.Add(session2);

  sessions.Kill();

  session1.Received().Kill();
  session2.Received().Kill();
}
</pre>

  <p>Now imagine that a company became interested in our web server and wants to turn it into a commercial product. The company strategy is as follows: users will be offered free version to try things out and when they pay, they will receive activation code.</p>

  <p>There is only one difference between the trial and full version - the trial version has a limit of only one active session at a given moment.</p>

  <p>This change of policy needs to be reflected in the session storage. So we add a logic that checks for the session limit and throws an exception as soon as the limit is exceeded. A specification of such behavior would look like this:</p>
  <pre class="brush: csharp">
[Test] public void
ShouldThrowExceptionWhenTryingToAddSessionsBeyondDefaultLimitOfOne()
{
  var sessions = new Sessions();
  var session1 = Any.InstanceOf&lt;Session&gt;();
  var session2 = Any.InstanceOf&lt;Session&gt;();

  sessions.Add(session1);
  
  Assert.Throws&lt;Exception&gt;(() =&gt; sessions.Add(session2));
}
</pre>

  <p>This, however, leaves us with another issue: what about the first spec mentioned in this post? If the limit of sessions is 1 by default, it will fail, since we're adding two sessions there. So we'll need to somehow extend the limit for the purpose of this spec.</p>

  <p>I assume that you're smart enough not to use Setup and Teardown methods in your unit-level specs (I'll have a post about why Setup and Teardown usually stink someday), so your "corrected" spec looks like this now:</p>
  <pre class="brush: csharp">
[Test] public void
ShouldKillAllContainedSessionsWhenItIsKilled()
{
  var sessions = new Sessions();
  var session1 = Substitute.For&lt;Session&gt;();
  var session2 = Substitute.For&lt;Session&gt;();
  sessions.Limit = 2;

  sessions.Add(session1);
  sessions.Add(session2);

  sessions.Kill();

  session1.Received().Kill();
  session2.Received().Kill();
}
</pre>

  <p>And so we added extending the session limit to 2. Now, doesn't this bother you? Look at the name of the spec - does it tell anything about a session limit? No, it doesn't. Let's think about the behavior as well - did it become invalid after we introduced the session limit? No, it didn't.</p>

  <p>So how did it happen that the session limit concept leaked to an unrelated specification? Is this a problem with the spec?</p>

  <p>No, it isn't. It's a problem with our production code design. In fact, this spec is just a symptom of what we did with the design:</p>

  <h3>We violated Single Responsibility Principle</h3>

  <p>That's right, folks, we really did it. Currently, the session storage is responsible not only for storing and accessing the sessions, it also knows EXACTLY what is the business-imposed limit and takes care of enforcing this limit. That's two responsibilities, not one.</p>

  <p>Ok, so we screwed up. How do we fix it?</p>

  <p>The easiest way is to have the limit-related logic isolated in a separate class. Because we want this class to be a result of implementing specifications (remember, test-driven ;-)), we undo the addition of the limit-related code to session storage class (and existing unit tests) and start over. Here's an example spec that will drive an implementation that respects Single Responsibility Principle. Implementing it will not impact other specs any way other than with a need to supply a dummy constructor parameter.</p>
  <pre class="brush: csharp">
[Test] public void
ShouldValidateNumberOfSessionsBeforeAddingANewOne()
{
  var sessionCountValidation 
    = Substitute.For&lt;SessionCountValidation&gt;()
  var sessions = new Sessions(sessionCountValidation);
  var sessionsCountBeforeAddingNewOne = sessions.Count;

  sessions.Add(Any.InstanceOf&lt;Session&gt;());

  sessionCountValidation.Received()
    .Perform(sessionsCountBeforeAddingNewOne);
}
</pre>

  <p>This way we crafted the signature of desired session count validation object. We can implement it (test-driven of course) as soon as this spec starts to pass.</p>

  <p>That's it. This is a simple lesson, but very important one. Remember: always listen to your tests - the advice may be priceless.</p>

  <p>See ya!</p>
</body>
</html>

<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Perfect from the start?</title>
  <link href="../Styles/Global.css" rel="stylesheet" type="text/css" />
</head>

<body>
  <p>Thanks go to Kuba Miara for inspiration</p>

  <p>This is a follow up post to the <a href="http://feelings-erased.blogspot.com/2012/05/tdd-is-good-teacher-both-demanding-and.html">TDD is a good teacher - both demanding and supportive</a> and discusses the second argument from my recent debate.</p>

  <h3 class="sigil_not_in_toc">Everything or nothing.</h3>

  <p>This argument states that you have to be "perfect from the start" or you die. Either you take everything or nothing. It's impossible for someone to take just a part of the benefits TDD has to offer.</p>

  <p>Here's my opinion on the topic: what executable specifications (AKA unit tests) bring you is never for free. Unit tests are additional code and like every code, it must be added, removed and changed to reach its target. Moreover, judging from static code analysis of a piece of code I did once, the unit tests code has often the highest coupling, so it's likely to change often. It's just that doing "full" TDD gets you the most. Below is the summary of different levels of TDD adoption (how I describe "progress towards full TDD" is of course arbitrary, so bear with me :-)), together with some rating based solely on my experience. By the way, when I say "isolation", I mean breaking dependencies between tested object and its collaborators, not between tests.</p>

  <h3 class="sigil_not_in_toc">1. No unit tests at all</h3><!--
Benefits:
- ability to write new code quickly (just "code and ship it") 
- model and remodel the code any way you want instantly
- quicker builds (less code) 
Cost:
- enormous time spent in debugging even for smallest mistakes
- codebase evolves in uncontrolled and undisciplined way
- No documentation of intent. Even the bestest code only answers your WHAT and HOW questions, but does not answer the WHETHER question (e.g. whether the objects reuse between requests is an accidential omittion or intended optimization?)
- no quick or definite way to measure how good your design is - the only way to do that is to stare at the code or launch static analysis tool, which tells you what's the problem, but does not suggest any way of solving it. Someday I'll post my favourite example of how far this can go. For now, just believe me :-).
- no quick way of discovering regression issues (instead of maybe running some kind of black box tests that are usually long and require setting up an environment where these tests can run).
- no safe way to do refactoring bigger than what your IDE allows you.
-->

  <p>Many great projects start as toys or experiments. We do them to learn something, to get play around with an idea or quickly to check the possibility of revenues (<a href="http://startupsuccesspodcast.com/2010/07/show-74-kent-beck-on-lean-startups-tdd-and-startups/">Kent Beck talked once about doing just this.</a>).</p>

  <p>It's quite fun while the design is pretty obvious and verifying the app requires just a few manual steps (like: run the app, click add and see a correct dialog open) - we can just "code and ship it".</p>

  <p>Once we get into a situation where the workflow gets less obvious or the logic is hard to verify (e.g. the app sends something via a socket - to check it manually, we'd have to write a test client or plug in a packet sniffer), this gets kind of ugly. The we usually launch a debugger, where we spend a lot of time tracking issues and correcting them (and tracking issues introduced by those corrections) - first using manual scenarios, later black-box level tests that at some point get created.</p>

  <p>Also, there are times, when we get stuck wondering "is it better to use inheritance here, or a tricky delegation? Should this method end up in class A or class B?". Sure, there are heuristics to evaluate design decisions, but it's still kind of arbitrary and ends with lengthy discussions and explaining the rationale all over again to each and every person questioning our design.</p>

  <table style="width: 100%;">
    <tr style="background-color: #f0f0f0;">
      <td>Build speed</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>
    </tr>

    <tr>
      <td>No need for debugging</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr style="background-color: #f0f0f0;">
      <td>Executable Specification</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr>
      <td>Measurable design quality</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr style="background-color: #f0f0f0;">
      <td>Protection from regression issues</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr>
      <td>Confidence of change</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr style="background-color: #f0f0f0;">
      <td>Ease of writing new test</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr>
      <td>Ease of maintaining existing tests</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>
    </tr>

    <tr style="background-color: #f0f0f0;">
      <td>Speed of transition from change in code to successful build</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>
    </tr>

    <tr>
      <td>Motivation to specify all code</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>
  </table>

  <h3 class="sigil_not_in_toc">2. Some poorly-isolated "unit" tests (or rather integration tests, as they're sometimes called)</h3>

  <p>This level is usually attained when some of the rebellious developers are angry with both time for setting up the environment necessary to perform box level tests and the time of execution of such tests. The idea is to write some of the scenarios dependent directly on entities in the code, to bypass mechanisms such as web or database, still exercising the domain logic. This makes sense when the domain logic is complex of its own.</p>

  <p>While shortening the time of setting up and running the tests, this approach makes the build slightly longer (additional code) and requires performing some isolation, at least from external dependencies (system clock, database, file system, network etc.), which, given a small amount of tests written this way, can be relatively cumbersome.</p>

  <p>On the bright side, having those tests let's us reason in a limited way about the design of the product, by asking questions like "is it easy to plug out the real database and substitute it for a fake?".</p>

  <table style="width: 100%;">
    <tr style="background-color: #f0f0f0;">
      <td>Build speed</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr>
      <td>No need for debugging</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr style="background-color: #f0f0f0;">
      <td>Executable Specification</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr>
      <td>Measurable design quality</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr style="background-color: #f0f0f0;">
      <td>Protection from regression issues</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr>
      <td>Confidence of change</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr style="background-color: #f0f0f0;">
      <td>Ease of writing new test</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr>
      <td>Ease of maintaining existing tests</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr style="background-color: #f0f0f0;">
      <td>Speed of transition from change in code to successful build</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr>
      <td>Motivation to specify all code</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>
  </table><!--
Benefits:
- some small ability to discover regression issues while changing the code
- some small ability to do safe refactoring
- some freedom in modelling and remodelling the code (small amount of tests covering huge sets of classes - so called integration tests)
- less time spent on debugging (in some cases you can debug on your own machine, without launching production environment and connecting remote debuggers etc.)
- partial documentation of intent
Cost:
- still have to debug a fair amount of time to find what actually caused test failure (since the tests cover so much, it's hard to actually tell looking at assertion failure what caused it)
- codebase evolves in uncontrolled and undisciplined way
- no quick or definite way to measure how good your design is
- lack of confidence when changing anything. Every time you have to analyse a huge test and reason whether it goes through the code you're planning to change or not.
- huge cost of maintaining test fixtures compared to amount of tests (you may end up creating ten test utilities just for three tests) - usually the (funny) conclusion is "let's write more tests". And we go to point c.
- hard to write a test - input must comply with all the constraints imposed throughout the code
- ability to write a test that will never fail
-->

  <h3 class="sigil_not_in_toc">3. Many poorly-isolated (coarse-grained) "unit" tests</h3>

  <p>This is what many projects end with. We have many tests exercising most of the scenarios in the code. It is safe to refactor, it is easier to see some intent documented by the tests. Because the tests are so many, the relative cost of writing helper fixtures and mini-frameworks to help us is relatively small.</p>

  <p>This, however, is the level where the point of having the tests is most fiercely discussed. Because of the low isolation, many tests go through the same paths of the code. This leads to a situation where one change in the code leads to tens of tests breaking from reasons not known outright. Since the tests are usually long and use many helper classes and functions, we have often to debug each test to discover its reason for failure. I've been in a project where updating such test suite used to take twice as long compared to updating the code.</p>

  <p>One more thing - the build slows down. Why? Because coarse-grained tests gather many dependencies. Let's say that we have 40 classes in our production code and each of our 20 tests is coupled to 30 of them - any change to any of those 30 classes makes all 20 tests recompile. This can cause a major headache, especially in slow-building languages such as C++.</p>

  <table style="width: 100%;">
    <tr style="background-color: #f0f0f0;">
      <td>Build speed</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr>
      <td>No need for debugging</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr style="background-color: #f0f0f0;">
      <td>Executable Specification</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr>
      <td>Measurable design quality</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr style="background-color: #f0f0f0;">
      <td>Protection from regression issues</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr>
      <td>Confidence of change</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr style="background-color: #f0f0f0;">
      <td>Ease of writing new test</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr>
      <td>Ease of maintaining existing tests</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr style="background-color: #f0f0f0;">
      <td>Speed of transition from change in code to successful build</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr>
      <td>Motivation to specify all code</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>
  </table><!--
Benefits:
- very good regression coverage 
- safe to refactor.
- even less time spent on debugging (multiple failing unit tests can tell you more clearly what's the problem)
- kind of good documentation of intent on integration level
Cost:
- no documentation of intent at class level. Still unsure what an actual class is responsible for in the overall behavior of the system.
- still need to launch debugger for many cases where tests fail
- codebase evolves in uncontrolled and undisciplined way - as long as the result is right at the end of the system, all is allowed inside 
- no quick or definite way to measure how good your design is
- maintainability issues - this is the worst of all - many tests go through the same code, so one code change causes up to twenty tests to fail, so correcting them becomes more and more of a pain. Usually the (funny) conclusion is "let's write less tests" and we come back to point b.
- hard to write a test - input must comply with all the constraints imposed throughout the code 
- ability to write a test that will never fail
-->

  <h3 class="sigil_not_in_toc">4. Many well isolated unit tests (first real unit tests)</h3>

  <p>Someone joins our team who really knows what unit tests are about. Usually this is a person practicing TDD, but is unsuccessful to convince the whole team to use it. Anyway, the person teaches us how to use mock objects and usually introduces some kind of mocking framework. Also, we learn about dependency injection and something about <a href="http://pragprog.com/magazines/2012-01/unit-tests-are-first">FIRST</a> or <a href="http://artofunittesting.com/">FICC</a> properties. With isolation rising, the test suite becomes increasingly maintainable - a situation when two tests fail for the same reason is quite rare, so we have less tests to correct and less debugging to do (because fine-grained test failure brings us to the failure reason without a need to debug).</p>

  <p>Everything starts to go more smoothly - the builds speed up, the documentation of intent does not double the one provided by box tests already, new tests are easy to write (since they usually test a single class - no supah long setup and teardown etc.), we can easily reason about the design quality <a href="http://www.sustainabletdd.com/2011/10/test-reflexology-part-1-first-post.html">with some heuristics</a> and a simple rule: from two design choices, the best is the one that requires fewer good unit tests.</p>

  <p>On the darker side: the team still didn't get the whole idea of test suite being an executable specification and is still stuck on the "testing" level. Because of this, they can discard writing unit tests for some of the implementation as "not worth testing", or "too simple". Also, since the tests are written after the code, this is usually not done with testability in mind, so each time a new part of code is written, it requires extra rework to be able to write good, isolated unit tests for. The last downside: the team does not benefit from <a href="http://feelings-erased.blogspot.com/2012/05/tdd-is-good-teacher-both-demanding-and.html">all the analysis and design techniques that TDD provides</a>.</p>

  <table style="width: 100%;">
    <tr style="background-color: #f0f0f0;">
      <td>Build speed</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr>
      <td>No need for debugging</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr style="background-color: #f0f0f0;">
      <td>Executable Specification</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr>
      <td>Measurable design quality</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr style="background-color: #f0f0f0;">
      <td>Protection from regression issues</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr>
      <td>Confidence of change</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr style="background-color: #f0f0f0;">
      <td>Ease of writing new test</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr>
      <td>Ease of maintaining existing tests</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr style="background-color: #f0f0f0;">
      <td>Speed of transition from change in code to successful build</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr>
      <td>Motivation to specify all code</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>
  </table><!--Benefits:
- very good regression coverage
- even more safe to refactor
- almost no time spent debugging - when unit test fails, it's mostly evident what's wrong
- good documentation of intent at class level - serves developers well
- very easy to add, change or remove unit tests - small scope of each unit test
- almost no fixtures - easier to get "the whole story" told by a test
- very good machanism to differentiate between better and worse design (out of two designs, the better is always the one that requires you to write less tests and shorter tests)
- very good maintainability - usually tests fail alone, for a specified reason and only for that reason
- imposes discipline when writing the code
Cost:
- after writing a code almost always have to refactor it to enable isolation and dependency injection for unit testing. It's usually an additional work on the same code just to be able to write unit tests
- still not perfect coverage ("ok, I've written the code, not unit tests... so, what was it that I implemented...?")
- low motivation to write unit tests ("this change was so easy, why should I test it?", then "I'm just adding one line, why should I test it", then "I'm just adding an if-else and almost copy paste between if and else, why should I test it?", then "This method is horrible, I don't know how to tests it. We need to rewrite the code some time in the future. In the meantime, there are other kinds of tests that will test this functionality")
- ability to write a test that will never fail
-->

  <h3 class="sigil_not_in_toc">5. Test Driven Development (with all the "bundled" tools)</h3>

  <p>This is the sweetest spot. The "testing" part is treated as a side effect of performing analysis and design with all the powerful techniques TDD brings. The code quality is superb (my experience is that code written using good TDD has often the best quality analysis results of all the code in the product). Code is written with testability in mind, so we don't pointlessly waste time reworking code we have already written just to enable isolation (we DO refactor sometimes, especially when we're doing triangulations, but this is not a waste - this is learning).</p>

  <p>In TDD, a failing test/spec is the reason to write any code, so <a href="http://www.sustainabletdd.com/2012/02/testing-best-practices-test-categories.html">even constants and enumerations have their own specs</a>. There is always motivation to write a test/spec, because there's no "too easy implementation" - there is always "an implementation that does not exist yet".</p>

  <p>People coming to this level (especially in languages with extensive IDE support, like Java or C#) quickly become super-productive killers, who quickly notice gaps in requirements, write beatifully designed code, at the same time producing: test suite for regression, an executable documentation of responsibilities and design decisions and a set of examples on how to use each class.</p>

  <table style="width: 100%;">
    <tr style="background-color: #f0f0f0;">
      <td>Build speed</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr>
      <td>No need for debugging</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>
    </tr>

    <tr style="background-color: #f0f0f0;">
      <td>Executable Specification</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>
    </tr>

    <tr>
      <td>Measurable design quality</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>
    </tr>

    <tr style="background-color: #f0f0f0;">
      <td>Protection from regression issues</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr>
      <td>Confidence of change</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>
    </tr>

    <tr style="background-color: #f0f0f0;">
      <td>Ease of writing new test</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>
    </tr>

    <tr>
      <td>Ease of maintaining existing tests</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr style="background-color: #f0f0f0;">
      <td>Speed of transition from change in code to successful build</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: silver;">&nbsp;</td>
    </tr>

    <tr>
      <td>Motivation to specify all code</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>

      <td style="background-color: green;">&nbsp;</td>
    </tr>
  </table>

  <h3 class="sigil_not_in_toc">Wrapping it up.</h3>

  <p>TDD is the most effective of all processes described above. It does not require perfection from the start, however, if you choose to forgo some of the practices and techniques, you obviously have to pay the price. What I try to teach people when I talk about TDD is that it is unnecessary to pay this price and by doing this, we introduce a waste. Which is what we'd like to avoid, right?</p>

  <p>Good night everyone!</p>
</body>
</html>

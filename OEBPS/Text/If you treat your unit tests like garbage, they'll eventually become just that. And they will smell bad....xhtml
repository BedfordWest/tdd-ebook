<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>If you treat your unit tests like garbage, they'll eventually become just that. And they will smell bad...</title>
</head>

<body>
  <p>Some time ago, I was TDDing a piece of code. My coworker glanced from the rear and, seeing a name of the spec I was writing, which was something like:</p>
  <pre>ShouldReportAllErrorsSortedAlphabeticallyWhenItEncountersErrorsDuringSearch()</pre>

  <p>he said:</p>

  <ul style="list-style-type: none;">
    <li>- What a crappy names you've got for your unit tests! They're so unreadable!</li>

    <li>- Why do you think they're crappy?</li>

    <li>- These are too long! I can't read this!</li>
  </ul>

  <p>I then suggested that we looked at the names of the unit tests he and his team were writing. I stopped at a unit test named</p>
  <pre>
TrySendingHttpRequest()
</pre>

  <p>and the following dialog occured:</p>

  <ul style="list-style-type: none;">
    <li>- See this one?</li>

    <li>- Yep.</li>

    <li>- When will it pass or fail? And what are you trying to achieve in this test by sending the HTTP request?</li>

    <li>- I don't know. I don't care. If it fails, I'll have to fix it, if not, I can forget it. That's all there is to it.</li>

    <li>- Well then, if my unit test names are unreadable, yours are useless.</li>
  </ul>

  <p>Then I said: "let's now look at the output from CruiseControl". I navigated to the cruise control unit test output web page of the project I was in. The unit test name I was writing was there, but written in a more human-readable form: "Should report all errors sorted alphabetically when it encounters errors during search". "See this?" - I said - this is our living documentation. He discarded this argument as "bringing unnecessary details" into the unit test suite.</p>

  <p>The next day, I sent him an excerpt from <a href="http://www.growing-object-oriented-software.com/">Growing Object Oriented Software Guided By Tests</a> book, which recommends to give unit tests names such as</p>
  <pre>notifiesListenersThatServerIsUnavailableWhenCannotConnectToItsMonitoringPort()</pre>

  <p>It did not convince him, however. The answer I received was: "We do it the way we do because it's comfortable for us. Just because we do something different than you doesn't mean we're doing it wrong. And whatever evidence you have that suggests long unit test names make sense, I will just keep doing what I'm doing right now. Period."</p>

  <h3 class="sigil_not_in_toc">The lesson</h3>

  <p>In case you didn't notice - this was not only a debate about long and short names of unit test names, this was a debate about what's the place of unit tests in team and project's ecosystem.</p>

  <p>While I personally value unit tests as a design tool, a feedback tool and a <a href="http://specificationbyexample.com/key_ideas.html">living documentation</a> on micro level, there are people who just don't care - for them, unit tests are some crappy code that passes through the production code to make sure nothing breaks. Those guys are not aware of the value unit tests AKA unit-level specification can bring to the team and the project.</p>

  <p>There are, however, downsides of this. If you treat your unit tests like garbage, they'll eventually become just this. E.g. for anyone that does not care about how unit tests are named (I assume that this someone would not even dare to use TDD - it's even more difficult than thinking of a descriptive name), here are a few things to consider:</p>

  <ol>
    <li>how do you know what situation does the test describe?</li>

    <li>how do you know whether the test describes a single situation, or few of them at the same time?</li>

    <li>how do you know what is the right assertion/set of assertions for the test?</li>

    <li>how do you know whether the test should stay or be removed when you modify the functionality covered by the test?</li>

    <li>how do you know whether the test or production code is at fault when you see unit test failure?</li>

    <li>how do you know that you will not introduce a duplicate test for a behavior that's already covered by another test when adding to test suite originally created by another team member?</li>

    <li>by looking at the unit testing tool output, how do you know whether the fix will be easy or not?</li>

    <li>how do you plan to maintain the test suite in the long term?</li>

    <li>how would you answer a new developer in your team who asks you " what is this test for"</li>

    <li>what's your plan on documenting the code you're writing?</li>

    <li>before writing the test, do you know what will you be testing? If so, then how do you know it?</li>

    <li>when writing a new suite of unit tests, how dou you keep track of behaviors/scenarios already covered and ones that still need to be covered?</li>
  </ol>

  <p>I could keep adding to the list, but let's stay with this for now. Feel free to comment on the questions above. If there's any demand, I'll post my answers from the perspective of a person doing TDD. What needs to be noted is that a person treating unit tests like garbage will probably have an answer to all of the above questions. The funny part is what these answers usually are.</p>

  <p>Apart from naming, there are other aspects of unit test that make it stink. That, however, I will leave for another time. See ya!</p>
</body>
</html>

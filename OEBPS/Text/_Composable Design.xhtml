<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Test-Driven Development - Extensive Tutorial</title>
        <link href="OEBPS/Styles/Global.css" rel="stylesheet" type="text/css"/>
    </head>
    <body>
        <h1>On Objects Composability</h1>
        <p>In this chapter, I will try to outline why objects' composability is a goal worth achieving and how it can be achieved. I am going to start with an example of unmaintainable code and will gradually fix its flaws in the next chapters. In this chapter, we are going to fix just one of the flaws, so the code we will end up will not be perfect by any means, still, it will be better by one quality.</p>


<h1>Example code and scenario</h1>

<p>The example we are going to work with is a class that implements company policies. For simplicity, there is only one policy: yearly incentive plan. Many corporations have what they call incentive plans. These plans are used to promote good behaviors and exceeding expectations by employees of a company.</p>

<p>In our case, the incentive plan will be one of the most stupid ones, but before we get to it, here is some background. Every employee in the company has a pay grade. An employee can be promoted to a higher pay grade, but the mechanics of how it works is something we are not going to deal in this example.</p>

<p>Normally, every year, everyone gets a raise. But to encourage behaviors that give an employee a higher pay grade, such employee cannot get raises indefinitely on a given pay grade. Each grade has its associated maximum pay. If this amount of money is reached, an employee does not get a raise.</p>

<p>Additionally, every employee on their 5th anniversary of working for the company, gets a special, one-time bonus which is twice their current payment.</p>

<p>The code of the class that implements this policy is shown below:</p>

<pre>public class CompanyPolicies : IDisposable
{
  readonly SqlRepository _repository
    = new SqlRepository();
  
  public void ApplyYearlyIncentivePlan()
  {
    var employees = _repository.CurrentEmployees();

    foreach(var employee in employees)
    {
      var payGrade = employee.GetPayGrade();
      if(employee.GetSalary() &lt; payGrade.Maximum)
      {
        var newSalary 
          = employee.GetSalary() 
          + employee.GetSalary() 
          / 10;
        employee.SetSalary(newSalary);
      }
      
      if(employee.GetYearseOfService() == 5)
      {
        var oneTimeBonus = employee.GetSalary() * 2;
        employee.SetBonusForYear(2014, oneTimeBonus);
      }
      
      employee.Save();
    }
  }
  
  public void Dispose()
  {
    _repository.Dispose();
  }
}</pre>

<h1>New Requirements: Support For Another Database</h1>

<p>Imagine one day, we need to support another database - a NoSQL one. So, there will be a possibility to configure which database is in use and use either an SQL one, or a NoSQL one.</p>

<p>To achieve this, we need to be somehow able to make the <code>CompanyPolicies</code> class database type-agnostic. Currently, it is coupled to an SQL storage, because it itself creates its database connection:</p>

<pre>public class CompanyPolicies : IDisposable
{
  readonly SqlRepository _repository
    = new SqlRepository();
</pre>

<p>There are a couple of ways of dealing with this problem, like:</p>

<h1>TOOOOOOOOOODOOOOOOOOO convert the list to separate sections</h1>

<ol>
  <li>Creating a constructor with an if statement inside to choose the database - this is a bad idea because other classes in our system use the database as well so the if statement will need to be duplicated.</li>
  <li>Changing the <code>SqlRepository</code> class itself so that it hides the information on the database used behind its own API - this could work, but will lead to every method duplicating the choice between the databases. If we decide to make the choice just once, we don't really need this class, because most of the time it will delegate to its inner implementation.</li>
  <li>Extract interface and pass XXX through the constructor.</li>
</ol>

<p>With the current design (we are creating our own instance), we have no way of using another object than just the <code>SqlRepository</code>, so we have to modify the CompanyPolicies to use something different.</p>

<p>We can solve this problem by using an interface instead of SqlRepository and pass an instance from outside of the class:</p>

<pre>public class CompanyPolicies : IDisposable
{
  readonly EmployeeSource _employeeSource;  

  public CompanyPolicies(EmployeeSource source)
  {
    _employeeSource = source;
  }
  
  //...code  
  
  public void Dispose()
  {
    _employeeSource.Dispose();
  }
}</pre>

<p>The <code>CompanyPolicies</code> is used in the code the following way:</p>

<pre>
var policies = new CompanyPolicies(new SqlRepository());

//... somewhere else in the code

policies.ApplyYearlyIncentivePlan();

//... somewhere else in the code

policies.Dispose();
</pre>

<p>Note two things: 1) as the employee source instance is passed by 3rd party, <code>CompanyPolicies</code> instances cannot assume the instance is used only by itself. Thus, it cannot neither initialize nor dispose of the instance. These two responsibilities have to be moved outside the class as well:</p>

<pre>public class CompanyPolicies
{
  readonly EmployeeSource _employeeSource;  

  public CompanyPolicies(EmployeeSource source)
  {
    _employeeSource = source;
  }
  
  public void ApplyYearlyIncentivePlan()
  {
    var employees = _repository.CurrentEmployees();

    foreach(var employee in employees)
    {
      var payGrade = employee.GetPayGrade();
      if(employee.GetSalary() &lt; payGrade.Maximum)
      {
        var newSalary 
          = employee.GetSalary() 
          + employee.GetSalary() 
          / 10;
        employee.SetSalary(newSalary);
      }
      
      if(employee.GetYearseOfService() == 5)
      {
        var oneTimeBonus = employee.GetSalary() * 2;
        employee.SetBonusForYear(2014, oneTimeBonus);
      }

      employee.Save();
    }
  }
}</pre>

<p>Note that we got rid of IDisposable, which is always good for abstraction... Now the usage pattern looks the same, only that now the same third party that created employees object, disposes of it. This is good, because one object has complete control over the lifetime of the employees object:</p>

<pre>SqlRepository repository = new SqlRepository();
var policies = new CompanyPolicies(repository);

//... somewhere else in the code

policies.ApplyYearlyIncentivePlan();

//... somewhere else in the code

repository.Dispose();
</pre>

<p>What have we achieved? Well, we allowed ourselves to choose the implementation of employees' storage. We did this by making the system composable - i.e. we can achieve different behaviors of the system by changing the way objects are composed together into a system. For example, instead of creating a <code>policies</code> object like this:</p>

<pre>SqlRepository repository = new SqlRepository();
var policies = new CompanyPolicies(repository);</pre>

<p>we can create it like this:</p>

<pre>NoSqlRepository repository = new NoSqlRepository();
var policies = new CompanyPolicies(repository);</pre>

<p>Or even, if we later decide to make the repository configurable by a strategy (e.g. there may be different definitions of what it means to get "current" employees) and extract the connection logic even further and make error reporting more configurable, we can do it like this:</p>

<pre>Repository repository = new RepositoryConfigurableByPolicies(
  new SqlDatabase(),
  new FilterToExcludeProbationEmployeesFromCurrent(),
  new ErrorReportingToLogFile()
);
var policies = new CompanyPolicies(repository);</pre>

<p>Everything without touching the <code>CompanyPolicies</code> class. Now, let us take the <code>ErrorReportingToLogFile</code> class and assume, that it is passed where an interface is required. We can, again, exchange this to something else, e.g.:</p>

<pre>Repository repository = new RepositoryConfigurableByPolicies(
  new SqlDatabase(),
  new FilterToExcludeProbationEmployeesFromCurrent(),
  new ErrorReportingThroughNetwork());
);</pre>

<p>Or make it configurable itself, e.g. with different formats and flushing algorithms (for performance purposes):</p>

<pre>Repository repository = new RepositoryConfigurableByPolicies(
  new SqlDatabase(),
  new FilterToExcludeProbationEmployeesFromCurrent(),
  new ErrorReportingToLogFile(
    new XmlLogFormat(),
    new FlushingDelayedUntilCachedContentIsMoreThan(
      Kilobytes.Value(5)
    )
  )
);</pre>

<p>Again, these modifications are all possible without touching the <code>RepositoryConfigurableByPolicies</code> class!</p>

<h1>Todo write about web of objects and how we can unplug parts of the web and plug in different parts to modify the system behavior without modifying the rest of the web</h1>

<h1>Todo write about composition root!</h1>



</html>
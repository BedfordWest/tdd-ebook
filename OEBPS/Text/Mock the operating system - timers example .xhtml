<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Mock the operating system: timers example</title>
  <link href="../Styles/Global.css" rel="stylesheet" type="text/css" />
</head>

<body>
  <p>Hi, today, I’d like to mention the topic of mocking the operating system and getting rid of it (especially the non-deterministic parts) as we write our specifications AKA unit tests.</p>

  <h3 class="sigil_not_in_toc">The use cases</h3>

  <p>In general, there are two cases where we interact with the operating system:</p>

  <ol>
    <li>We tell our code to use the operating system’s resources (start a thread, write to a hard drive etc.)</li>

    <li>We tell the operating system to use our code (when a timer expires, when a thread execution finishes etc.)</li>
  </ol>

  <h3 class="sigil_not_in_toc">Timers</h3>

  <p>The topic of today’s post is a combination of both above cases. Timers work as a way to say “in X milliseconds (or any other time unit), invoke Y and in the meantime, let me do my job.”</p>

  <p><a href="http://1.bp.blogspot.com/-RIn6HavVmco/T-I47IqIwmI/AAAAAAAAAIE/lRzchNu4IS4/s1600/TimerDiagram.png" imageanchor="1" style="margin-left:1em; margin-right:1em"><img alt="" border="0" height="121" src="http://1.bp.blogspot.com/-RIn6HavVmco/T-I47IqIwmI/AAAAAAAAAIE/lRzchNu4IS4/s400/TimerDiagram.png" width="400" /></a></p>

  <p>The scheduling phase is where our code uses the timer and the calling back phase is where the timer uses our code. But before I show you how to properly handle this kind of situation, let’s examine how things can go wrong.</p>

  <h3 class="sigil_not_in_toc">A Baaad Idea</h3>

  <p>Let’s assume that our specified class invokes an action periodically, each time passing in the current time. Also, let’s assume that we don’t care about the current time value (e.g. whether the passed time is really current) - in the real world we would, but this is just a toy example, so please bear with it. The most widely seen (but wrong - read on) way of writing a spec of a class that executes some code periodically usually consists of the following steps</p>

  <ol>
    <li>Make the object using the timer start this timer with a callback interval of <strong>X</strong> (so each <strong>X</strong> units of time, let’s say seconds, the timer will call back)</li>

    <li>Sleep for X*Y units of time (where <strong>Y</strong> is any positive integer) + some slight tolerance</li>

    <li>After the spec wakes up from the sleep, assert that callback was called <strong>Y</strong> times</li>
  </ol>

  <p>Let’s quickly examine how would an implementation of such reasoning look like:</p>
  <pre class="brush: c#">
[Test]
public void ShouldPingPeriodically()
{
  int actualCallbackCount = 0;
  int interval = 4000;
  int expectedCallbackCount = 3;
  int tolerance = 1000;

  var timeNotification = 
    new CurrentTimeNotification( _ =&gt; actualCallbackCount++ );

  timeNotification.Schedule(interval);
  Thread.Sleep(interval * expectedCallbackCount + tolerance);
  timeNotification.Halt();

  Assert.AreEqual(expectedCallbackCount, actualCallbackCount);
}
</pre>

  <p>This approach has one disadvantage - the interval * expectedCallbackCount is not the total time that is spent in tested code - there’s one more thing we have to take into account, which is the duration of execution of the callback passed to CurrentTimeNotification constructor. Also, usually we don’t invoke this code directly from the timer, because callbacks executed by the timer often require a specific signature which our passed action does not provide (if you’re curious about the details, read TimerCallback delegate documentation on MSDN), so probably there is an additional code that’s executed by the timer and this code invokes the action that we pass in. Usually the 1-second tolerance is enough to cater for this (by the way, remember it’s really 1 second for all the calls, so each call must take under (1/expectedCallbackCount) seconds), but what if we run unit tests on a developer machine that’s performing another build at the same time and is short on resources? Can the execution of the additional code that we just mentioned take more than the assumed tolerance? Of course it can! So what do we do about it?</p>

  <h3 class="sigil_not_in_toc">A Better solution</h3>

  <p>The time has come to draw a line between the behaviors of our code and the operating system. In a specification of a class using a timer, we want to describe three behaviors in particular:</p>

  <ol>
    <li>It should create the timer passing desired method as callback</li>

    <li>It should schedule the timer for desired number of time units</li>

    <li>It should perform a desired behavior when the callback is invoked</li>
  </ol>

  <p>To achieve this goal, we have to get rid of the timer by creating a thinnest possible wrapping layer. This layer has to be super thin because it’s the code we’re NOT going to write specs against. So, here we go - a timer wrapper:</p>
  <pre class="brush: c#">
public interface IPeriodicExecution
{
  TimerCallback Callback { get; }
  void Schedule(int milliseconds);
  void Halt();
}

public class PeriodicExecution : IPeriodicExecution
{
  private Timer timer;

  public TimerCallback Callback
  {
    get; private set;
  }

  public PeriodicExecution(TimerCallback callback)
  {
    timer = new Timer(callback);
    Callback = callback;
  }

  public void Schedule(int milliseconds)
  {
    timer.Change(0, milliseconds);
  }

  public void Halt()
  {
    timer.Change(0, Timeout.Infinite);
  }
}
</pre>

  <p>As you can see, the wrapper is really thin. The only unclear element is this Callback property. We’ll reveal what it is for in a moment. In the meantime, note that the timer callback is passed in a constructor. We can’t mock constructors, so from the list of the three behaviors outlined in the beginning of this section, we wouldn’t be able to specify the first one. In order to be able to do that, we need to introduce another thin layer - a factory!</p>
  <pre class="brush: c#">
public interface IPeriodicExecutionFactory
{
  IPeriodicExecution Create(TimerCallback callback);
}

public class PeriodicExecutionFactory
{
   public 
   IPeriodicExecution Create(TimerCallback callback)
   {
     return new PeriodicExecution(callback);
   }
}
</pre>

  <p>By the way, this is not the main topic of this post, but note that because the IPeriodicExecution interface has this callback property I mentioned, we can actually test-drive this factory object in the following way:</p>
  <pre class="brush: c#">
[Test]
public void ShouldCreatePeriodicExecutionWithSpecifiedCallback()
{
  var anyCallback = Substitute.For&lt;TimerCallback&gt;();
  var factory = new PeriodicExecutionFactory();
  var periodicExecution = factory.Create(anyCallback);

  Assert.AreSame(anyCallback, periodicExecution.Callback);
}
</pre>

  <p>Ok, now we’re ready to write the specs for the three behaviors from this section start. The first one: <strong>“Should create the timer passing desired method as callback”</strong>:</p>
  <pre class="brush: c#">
[Test]
public void 
ShouldSetupPeriodicExecutionCallbackToNotifyAboutCurrentDateTime()
{
  //GIVEN
  var anyAction = Substitute.For&lt;Action&lt;DateTime&gt;&gt;();
  var factory = Substitute.For&lt;IPeriodicExecutionFactory&gt;();

  //WHEN
  var notification = new CurrentTimeNotification2(anyAction, factory);

  //THEN
  factory.Received().Create(notification.NotifyAboutCurrentTime);
}
</pre>

  <p>Now the second one: <strong>“Should schedule the timer for desired number of time units”</strong>:</p>
  <pre class="brush: c#">
[Test]
public void 
ShouldSchedulePeriodicExecutionEverySpecifiedNumberOfMilliseconds()
{
  //GIVEN
  var anyAction = Substitute.For&lt;Action&lt;DateTime&gt;&gt;();
  var factory = Substitute.For&lt;IPeriodicExecutionFactory&gt;();
  var periodicExecution = Substitute.For&lt;IPeriodicExecution&gt;();
  var anyNumberOfMilliseconds = Any.PositiveInteger();

  factory.Create(Arg.Any&lt;TimerCallback&gt;()).Returns(periodicExecution);
  var notification = new CurrentTimeNotification2(anyAction, factory);

  //WHEN
  notification.Schedule(anyNumberOfMilliseconds);

  //THEN
  periodicExecution.Received().Schedule(anyNumberOfMilliseconds);
}
</pre>

  <p>And the third one: <strong>“Should perform a desired behavior when the callback is invoked”</strong>:</p>
  <pre class="brush: c#">
[Test]
public void 
ShouldInvokeActionWithCurrentTimeWhenTimerExpires()
{
  //GIVEN
  bool gotCalled = false;
  var factory = Substitute.For&lt;IPeriodicExecutionFactory&gt;();
  var notification = 
    new CurrentTimeNotification2(_ =&gt; gotCalled = true, factory);

  //WHEN
  notification.NotifyAboutCurrentTime(Any.Object());

  //THEN
  Assert.IsTrue(gotCalled);
}
</pre>

  <p>And that’s it. Note that this set of three specifications better describe what the actual object does, not how it works when connected to the timer. This way, they’re more accurate as specifications of the class than the one using Thread.Sleep().</p>

  <h3 class="sigil_not_in_toc">Summary</h3>

  <p>In this post, I tried to show how to approach timer-based designs. The same approach can be used for mocking pretty much every non-deterministic or time-based or threaded element in our implementation.</p>

  <p>Remember, try to keep your design separated from your implementation.</p>
</body>
</html>

<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Specifying boundaries</title>
</head>

<body>
  <h1>Specifying Behaviors Near Boundaries</h1>

  <h2>A Disclaimer</h2>

  <p>Before I begin, I have to admit that this chapter is mostly based on the material from a series of posts by Scot Bain and Amir Kolsky from the blog sustainabletdd.com and their upcoming book Sustainable Test Driven Development. I like their idea of boundaries so much that I just follow the guidelines they outlined. This chapter is going to be a rephrase of these guidelines. I placed it here so that you have all the important topics covered in one place, but I encourage you to read the original blog posts on this subject.</p>

  <h2>Sometimes, anonymous value is not enough</h2>

  <p>When we specify a behavior, there are times when this behavior should be the same no matter what arguments we pass in to constructor or invoked methods. An example would be an addition of two numbers - whatever numbers we would supply, the answer would always be a sum of those numbers:</p>
  <pre>[Fact] public void
ShouldCalculateTheSumOfPassedNumbers()
{
  //GIVEN
  var a = Any.Integer();
  var b = Any.Integer();

  //WHEN
  var result = new Sum().CalculateFrom(a, b);

  //WHEN
  Assert.Equal(a + b, result);
}</pre>

  <p>In this case, the integer numbers can really be "any" - the behavior should always occur. <strong>TODO write about "ANY"</strong></p>

  <p>Sometimes, however, the expected behavior varies depending on what the input arguments of a method or class constructor are. E.g. a feature is allowed only for "admin" user, but denied for all others. Another example would be that some shops are open from 10:00 to 18:00, so if we had a method to ask whether the shop is currently open, we would expect it to answer differently based on what the current time is.</p>

  <p>In such cases, Scott and Amir offer us other guidelines for choosing input values.</p>

  <h2>Exceptions to the rule</h2>

  <p>There are times, when a Statement is true for every value except one (or more) explicitly specified. For example, in Poland, high school students are graded for exams between "mediocre" and "very good". Every grade means the exam is passed with an exception of "mediocre". If we imagine we have to specify an object that decides whether the exam is passed based on rating, we would have to write two Statements: one for the mediocre rating and other for all the others.</p>

  <p>Here is the Statement for mediocre grade (let us imagine that all grades are members of an enum):</p>
  <pre>[Fact] public void
ShouldNotPassTheExamWhenGradeIsMediocre()
{
  //GIVEN
  var decision = new PassOrNotDecision();

  //WHEN
  var examPassed = decision.MakeFor(Grades.Mediocre);

  //THEN
  Assert.False(examPassed);
}</pre>

  <p>Note that here, we used the literal value of <code>Grades.Mediocre</code>. This is because no other value gives the same behavior, so generating the value would not make sense.</p>

  <p>The second Statement is for all the other cases. Here, we are going to use another method of the <code>Any</code> class for generating ay enum member other than specified:</p>
  <pre>[Fact] public void
ShouldPassTheExamWhenGradeIsOtherThanMediocre()
{
  //GIVEN
  var decision = new PassOrNotDecision();

  //WHEN
  var examPassed 
    = decision.MakeFor(Any.Besides(Grades.Mediocre));

  //THEN
  Assert.True(examPassed);
}</pre>

  <p>Here, <code>Any.Besides()</code> takes care of the value generation, producing a nice, readable code as a side effect.</p>

  <p>The example shown above assumes there is only one exception to the rule (the mediocre grade). However, this concept can be scaled up to more values, as long as it is a finished, discrete set. If there are multiple exceptional values that produce the same behavior, a single Statement is sufficient to cover them all (using <code>Any</code> class and making the following call for exception Statement: <code>Any.Of(value1, value2)</code> and the following for the rest: <code>Any.OtherThan(value1, value2)</code>). However, when there are multiple exceptions to the rule and each one triggers a different behavior, each one deserves its own Statement.</p>

  <h2>Rules Valid Within Boundaries</h2>

  <p>Sometimes, a behavior varies around a numerical boundary. the simplest example would be calculating the absolute value:</p>

  <ol>
    <li>for any X less than 0, the result is -X (e.g. absolute value of -1.5 is 1.5)</li>

    <li>for any X greater or equal to 0, the result is X (e.g. absolute value of 3 is 3).</li>
  </ol>

  <p>As you can see, there's a boundary and the boundary value is 0. To illustrate this, let's try and write two Statements assuming we're implementing the absolute value function for integers. The first Statement is for values smaller than 0:</p>
  <pre>[Fact] public void
ShouldNegateTheNumberWhenItIsLessThan0()
{
  //GIVEN
  var function = new AbsoluteValueCalculation();
  var lessThan0 = -1;

  //WHEN
  var result = function.PerformFor(); //TODOOOOOOOOOOOOOOOOOOOOOOOOO

  //THEN
}</pre>

  <p>TODO: with strings. TODO: with date time, TODO: explain that constants should always be used instead of literal values.</p>
</body>
</html>

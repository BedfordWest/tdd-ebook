<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Test Driven Development - objections, part 1</title>
</head>

<body>
  <p>Since you're reading this blog, you probably have your own, more or less informed, view on TDD. Maybe you already read a book or two, maybe you've got two (or twelve) years of TDD practice on your back, but maybe you've heard about TDD and about it being "cool" only recently and are merely striving to learn more? If that's the case you've probably got a lot of doubts on whether TDD is really beneficial or whether it will prove beneficial in the specific environment you happen to work in. You're eager to get started, but you wonder whether the time and effort spent on learning TDD will prove itself to be well spent.</p>

  <p>During my adventure with TDD, I encountered many objections, either from myself (and they were dispelled by others) or from other engineers (these I tried to dispel myself). Today, I'd like to comment on some of those objections I met with when talking about TDD. In particular:</p>

  <ol>
    <li><strong>Not enough time</strong></li>

    <li><strong>TDD will slow us down, because we'll have to create a lot of additional code</strong></li>

    <li><strong>TDD will slow us down, because we'll have to maintain a lot of additional code</strong></li>

    <li><a href="http://feelings-erased.blogspot.com/2012/12/test-driven-development-objections-part_30.html">We don't have the necessary skills or experience</a></li>

    <li><a href="http://feelings-erased.blogspot.com/2012/12/test-driven-development-objections-part_30.html">We don't have the necessary tools</a></li>

    <li><a href="http://feelings-erased.blogspot.com/2012/12/test-driven-development-objections-part_30.html">(This one is unit testing specific) There are already other kinds of tests, we don't need unit tests?</a></li>

    <li><a href="http://feelings-erased.blogspot.com/2012/12/test-driven-development-objections-part_30.html">It's very hard to perform with legacy code</a></li>

    <li><a href="http://feelings-erased.blogspot.com/2013/01/test-driven-development-objections-part.html">I already know how to write a testable code, TDD will not really improve my design</a></li>

    <li><a href="http://feelings-erased.blogspot.com/2013/01/test-driven-development-objections-part.html">We've got enough quality and we're doing fine without TDD</a></li>

    <li>My manager won't let me do TDD</li>

    <li><a href="http://feelings-erased.blogspot.com/2013/01/test-driven-development-objections-part.html">There's no "scientific proof" and enough research on whether TDD really provides a return of investment</a></li>
  </ol>

  <p>This post is around the first three points, marked with <strong>strong text</strong>. The later points will be discussed in part 2 of this post. Ok, let's go!</p>

  <h3>1. Not enough time</h3>

  <p>This is my favorite objection, just because dispelling it is so fun and easy. I usually approach this kind of objections with <a href="http://gojko.net/2012/05/31/how-to-solve-not-enough-time/">Gojko Adzic's argument on how to solve Not Enough Time</a>. You see, "not enough time" is always a facade reason - it is there only to hide the true one. The only direct solution to "not enough time" is to "make more time", which, by the way, is impossible. Luckily, we can restate it into something solvable like "something prevents me from allocating time for TDD". The further actions depend on what is this "something". Maybe it's a boss that will punish their employees for not fulfilling the short term goals? Maybe it's lack of appropriate knowledge or training? Anyway, these issues can be dealt with. "Not enough time" can't.</p>

  <h3>2. TDD will slow us down, because we'll have to create a lot of additional code</h3>

  <p>This is actually a (partially) valid argument. TDD really does lead to creating more code, which costs time. However, this does not necessarily mean that the overall development process takes more time than not writing this additional code. This is because this "test code" is not being written just for the sake of "being written" :-). The act of writing and the code that is created as a result of this writing provide a great value to a single developer and an entire team.</p>

  <p>TDD aids developers in the process of analysis. What would otherwise be a mental effort to make everything up inside your head, turns into concrete failing or impossible-to-write code. This generates questions that are usually better asked sooner than later. Thanks to this, there's no escape from facing uncertainty.</p>

  <p>The case is different (at least for me) when developing without TDD. In this approach, I discovered that I tend to write what I know first, leaving what I don't know for later (in hope that maybe I'll learn something new along the way that will answer my questions and lower uncertainty). While the process of learning is surely valuable, the uncertainty must be embraced instead of being avoided. Getting away from answering some key questions and leaving them for later generates a lot of rework, usually at the end of iteration, where it's very dangerous.</p>

  <p>When I do TDD and I encounter a behavior that I don't know how to specify, I go talk with stakeholders ("Hey, what should happen when someone creates a subscription for magazines already issued?"). Also, If someone asks me to clarify my question, I can show them the spec/test I'm trying to write for the behavior and say "look, this does not work" or "so the output should be what?". This way, I can get many issues if not solved, then at least on the table much sooner than in case of non-TDD coding. It helps me eliminate rework, save some time and make the whole process more predictable.</p>

  <p>TDD also provides a big help when designing. It lets you do your design outside-in, beginning with the domain and its work-flows, not the reusable, versatile, framework-like, one-size-fits-all utility objects that end up having only 30% of its logic ever used. This way, TDD lets you <strong>avoid over-design</strong> (by the way, code reuse is a good thing, it's just that preliminary generalization is as dangerous as preliminary optimization).</p>

  <p>On the other hand, by promoting a quality called <a href="http://www.netobjectives.com/files/books/esad/essential-skills-define-tests-up-front.pdf">"testability"</a>, it promotes loose coupling, high cohesion and small, focused, well encapsulated objects. I already did some posts on that, so I'm not gonna delve more into this topic here. Anyway, striving for high testability helps <strong>avoid under-design</strong>.</p>

  <p>Another way to think about the process of doing TDD is that you're actually documenting your design, its assumptions, legal and illegal behaviors. Others will be able to read it and learn from it when they face the task of using your abstractions in a new context.</p>

  <h3>3. TDD will slow us down, because we'll have to maintain a lot of additional code</h3>

  <p>It's true that, when done wrong, TDD produces a mass of code that is hard to maintain. Refactoring becomes a pain, each added functionality breaks dozens of existing specs/tests and the teams seriously consider abandoning the practice.</p>

  <p>This happens more often when the teams do not adopt TDD, but rather stick with unit tests and do it only for the sake of testing.</p>

  <p>The truth is that TDD, when done right, helps avoid such situations. Also, this help is actually one of its goals! To achieve this, however, you need two things.</p>

  <p>The first one is knowing TDD good practices that help you write only the specs/tests that you need, focus on behavior and discover interactions between different objects, limiting an impact of a change to a small number of specs/tests. I actually didn't write about it yet on my blog, but there are some <a href="http://jmock.org/oopsla2004.pdf">other sources of information</a>. Anyway, this issue is easily solvable by a combination of training, mentoring, books and experience.</p>

  <p>the second thing is "listening to the tests", covered both by <a href="http://www.youtube.com/watch?v=0zLDAl3zPks">Steve Freeman &amp; Nat Pryce</a> (they call it Synaesthesia) and <a href="http://www.sustainabletdd.com/2011/10/test-reflexology-part-1-first-post.html">Amir Kolsky &amp; Scott Bain</a> (they call it Test Reflexology). The big idea is that difficulties in writing and maintaining specs/tests are a very much desired feedback on quality of your design (also make sure to look at James Grenning's post on <a href="http://www.renaissancesoftware.net/blog/archives/382">TDD as a design rot radar</a>).</p>

  <p>In other words, as long as the design is good and you know how to write tests/specs, this whole objection is not a problem. Of course, there is still a code to maintain, but I found it to be an easy task.</p>

  <p>Another thing to keep in mind is that by maintaining specs/tests, you're actually maintaining a living documentation on several levels (because TDD is not solely limited to unit level). Just think how much effort it takes to keep an NDoc/JDoc/Doxygen documentation up to date - and you never actually know whether such documentation speaks the truth after a year of maintenance. Things get better with tests/specs, which can be compared with the code just by running them, so the maintenance is easier.</p>

  <h3>Part 2 is already written! <a href="http://feelings-erased.blogspot.com/2012/12/test-driven-development-objections-part_30.html">Read it!</a></h3>

  <p>Also, feel free to leave your comment. How do you deal with these objections when you encounter them? Do you have any patterns you can share?</p>
</body>
</html>
